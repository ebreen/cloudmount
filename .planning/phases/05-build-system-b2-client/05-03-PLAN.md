---
phase: 05-build-system-b2-client
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - CloudMountKit/B2/B2Types.swift
  - CloudMountKit/B2/B2Error.swift
  - CloudMountKit/B2/B2HTTPClient.swift
autonomous: true

must_haves:
  truths:
    - "B2 API response types correctly decode real B2 v4 JSON responses including numeric-as-string fields"
    - "B2HTTPClient maps 1:1 to every required B2 endpoint: authorize, list files, download, get upload url, upload, delete, copy"
    - "B2 error responses are parsed into typed Swift errors with retryability classification"
    - "All HTTP requests include required User-Agent header"
  artifacts:
    - path: "CloudMountKit/B2/B2Types.swift"
      provides: "Codable models for all B2 API request/response types"
      contains: "struct B2AuthResponse"
    - path: "CloudMountKit/B2/B2Error.swift"
      provides: "B2Error enum with isAuthExpired, isRetryable classification"
      contains: "enum B2Error"
    - path: "CloudMountKit/B2/B2HTTPClient.swift"
      provides: "Stateless HTTP layer with 1:1 B2 endpoint mapping"
      contains: "struct B2HTTPClient"
  key_links:
    - from: "B2HTTPClient"
      to: "URLSession"
      via: "async/await data(for:) calls"
      pattern: "session\\.data\\(for:"
    - from: "B2HTTPClient"
      to: "B2Types"
      via: "JSONDecoder for response parsing"
      pattern: "JSONDecoder.*decode"
    - from: "B2HTTPClient"
      to: "B2Error"
      via: "HTTP status code to error mapping"
      pattern: "B2Error"
---

<objective>
Build the B2 API types, error types, and low-level HTTP client layer in CloudMountKit. The HTTP client maps 1:1 to B2 Native API v4 endpoints — stateless, no caching, no token management. This is the foundation the high-level B2Client actor builds on.

Purpose: Create a correct, complete B2 HTTP layer that handles all the API quirks (numeric-as-string fields, two-step upload, pagination support) so the high-level client can focus on domain logic.
Output: Three files providing B2 response types, error classification, and a complete HTTP endpoint mapping.
</objective>

<execution_context>
@~/.config/Claude/get-shit-done/workflows/execute-plan.md
@~/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-build-system-b2-client/05-RESEARCH.md
@.planning/phases/05-build-system-b2-client/05-CONTEXT.md
@.planning/phases/05-build-system-b2-client/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: B2 API types and error types</name>
  <files>
    CloudMountKit/B2/B2Types.swift
    CloudMountKit/B2/B2Error.swift
  </files>
  <action>
    Create two files in `CloudMountKit/B2/`:

    **1. `B2Types.swift` — All Codable models for B2 API v4 request/response types:**

    FlexibleInt64 (CRITICAL — B2 returns numeric fields as strings sometimes):
    ```swift
    public struct FlexibleInt64: Codable, Hashable {
        public let value: Int64
        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let intValue = try? container.decode(Int64.self) {
                value = intValue
            } else if let stringValue = try? container.decode(String.self),
                      let parsed = Int64(stringValue) {
                value = parsed
            } else if container.decodeNil() {
                value = 0
            } else {
                throw DecodingError.typeMismatch(Int64.self, .init(codingPath: decoder.codingPath, debugDescription: "Expected Int64 or String"))
            }
        }
        public init(_ value: Int64) { self.value = value }
        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            try container.encode(value)
        }
    }
    ```

    Required response types (from 05-RESEARCH.md "B2 Response Types" section):
    - `B2AuthResponse` — from b2_authorize_account (includes apiInfo.storageApi nested structure)
    - `B2ApiInfo` — nested in auth response
    - `B2StorageApiInfo` — contains apiUrl, downloadUrl, recommendedPartSize, absoluteMinimumPartSize, allowed
    - `B2Allowed` — capabilities, buckets array, namePrefix
    - `B2AllowedBucket` — id, name
    - `B2FileInfo` — from b2_list_file_names (fileName, contentLength as FlexibleInt64, uploadTimestamp as FlexibleInt64, action, fileId, contentType, contentSha1) with computed `isDirectory` and `baseName` properties
    - `B2ListFilesResponse` — files array + nextFileName for pagination
    - `B2UploadUrlResponse` — from b2_get_upload_url (bucketId, uploadUrl, authorizationToken)
    - `B2UploadFileResponse` — from b2_upload_file (fileId, fileName, contentLength, etc.)
    - `B2CopyFileResponse` — from b2_copy_file (fileId, fileName, etc.)
    - `B2DeleteFileResponse` — from b2_delete_file_version (fileId, fileName)
    - `B2ErrorResponse` — from error responses (status, code, message)
    - `B2ListBucketsResponse` — from b2_list_buckets
    - `B2BucketInfo` — bucket details (bucketId, bucketName, bucketType, etc.)

    Also define a custom JSONDecoder extension for B2:
    ```swift
    extension JSONDecoder {
        public static let b2Decoder: JSONDecoder = {
            let decoder = JSONDecoder()
            // B2 uses camelCase natively — no key strategy needed
            return decoder
        }()
    }
    ```

    And define User-Agent constant:
    ```swift
    public enum B2Constants {
        public static let userAgent = "CloudMount/2.0.0+swift/6.0+macOS/26"
        public static let apiBaseUrl = "https://api.backblazeb2.com"
        public static let apiVersion = "v4"
        /// SHA-1 of empty data (for folder creation)
        public static let emptySHA1 = "da39a3ee5e6b4b0d3255bfef95601890afd80709"
    }
    ```

    All types must be `public` and conform to `Codable` (and `Hashable` where practical). Use the exact field names from the B2 API docs — they're camelCase, so no `keyDecodingStrategy` needed.

    **2. `B2Error.swift` — Error types with retry/auth classification:**

    ```swift
    public enum B2Error: Error, LocalizedError {
        case unauthorized(code: String, message: String)
        case badRequest(code: String, message: String)
        case forbidden(code: String, message: String)
        case notFound(code: String, message: String)
        case tooManyRequests(retryAfter: TimeInterval?)
        case serverError(status: Int, code: String, message: String)
        case networkError(underlying: Error)
        case decodingError(underlying: Error)
        case invalidURL(String)

        public var isAuthExpired: Bool { ... }  // true for bad_auth_token, expired_auth_token
        public var isRetryable: Bool { ... }    // true for tooManyRequests, serverError, authExpired
        public var retryAfter: TimeInterval? { ... }  // for 429 responses
        public var errorDescription: String? { ... }
    }
    ```

    Provide a static factory method to create B2Error from HTTP response:
    ```swift
    static func from(httpResponse: HTTPURLResponse, data: Data) -> B2Error {
        // Parse B2ErrorResponse from data
        // Map HTTP status to error case
        // 401 → .unauthorized, 400 → .badRequest, 403 → .forbidden,
        // 404 → .notFound, 429 → .tooManyRequests (parse Retry-After header),
        // 500+ → .serverError
    }
    ```
  </action>
  <verify>
    - `ls CloudMountKit/B2/B2Types.swift CloudMountKit/B2/B2Error.swift` — both exist
    - `grep "FlexibleInt64" CloudMountKit/B2/B2Types.swift` — found
    - `grep "B2AuthResponse" CloudMountKit/B2/B2Types.swift` — found
    - `grep "B2ListFilesResponse" CloudMountKit/B2/B2Types.swift` — found
    - `grep "isAuthExpired" CloudMountKit/B2/B2Error.swift` — found
    - `grep "isRetryable" CloudMountKit/B2/B2Error.swift` — found
    - `xcodebuild -project CloudMount.xcodeproj -scheme CloudMountKit -configuration Debug build 2>&1 | tail -3` shows BUILD SUCCEEDED
  </verify>
  <done>All B2 API response types and error types exist, compile, and handle B2 quirks (FlexibleInt64, error classification, retry-after parsing).</done>
</task>

<task type="auto">
  <name>Task 2: B2HTTPClient — stateless 1:1 endpoint mapping</name>
  <files>
    CloudMountKit/B2/B2HTTPClient.swift
  </files>
  <action>
    Create `CloudMountKit/B2/B2HTTPClient.swift` — a stateless HTTP layer that maps 1:1 to B2 Native API v4 endpoints. No caching, no token management, no retry logic at this level.

    ```swift
    public struct B2HTTPClient: Sendable {
        private let session: URLSession

        public init(session: URLSession = .shared) {
            self.session = session
        }

        // MARK: - Authentication

        /// b2_authorize_account — GET with Basic auth
        public func authorizeAccount(keyId: String, applicationKey: String) async throws -> B2AuthResponse

        // MARK: - Bucket Operations

        /// b2_list_buckets — POST (requires accountId in body)
        public func listBuckets(apiUrl: String, authToken: String, accountId: String) async throws -> B2ListBucketsResponse

        // MARK: - File Listing

        /// b2_list_file_names — GET with query parameters
        /// Supports prefix, delimiter, startFileName, maxFileCount
        /// Returns a SINGLE page — caller must handle pagination via nextFileName
        public func listFileNames(
            apiUrl: String,
            authToken: String,
            bucketId: String,
            prefix: String? = nil,
            delimiter: String? = nil,
            startFileName: String? = nil,
            maxFileCount: Int = 1000
        ) async throws -> B2ListFilesResponse

        // MARK: - Download

        /// b2_download_file_by_name — GET with optional Range header
        /// Returns raw (Data, HTTPURLResponse) for the caller to handle
        public func downloadFileByName(
            downloadUrl: String,
            authToken: String,
            bucketName: String,
            fileName: String,
            range: ClosedRange<Int64>? = nil
        ) async throws -> (Data, HTTPURLResponse)

        // MARK: - Upload (two-step)

        /// b2_get_upload_url — GET, returns upload URL + auth token
        public func getUploadUrl(
            apiUrl: String,
            authToken: String,
            bucketId: String
        ) async throws -> B2UploadUrlResponse

        /// b2_upload_file — POST to the upload URL from getUploadUrl
        /// IMPORTANT: Uses the upload-specific auth token, NOT the account auth token
        /// Requires Content-Length, X-Bz-File-Name (percent-encoded), Content-Type,
        /// X-Bz-Content-Sha1, and optionally X-Bz-Info-src_last_modified_millis
        public func uploadFile(
            uploadUrl: String,
            uploadAuthToken: String,
            fileName: String,
            contentType: String,
            data: Data,
            sha1Hex: String,
            lastModifiedMillis: Int64? = nil
        ) async throws -> B2UploadFileResponse

        // MARK: - Delete

        /// b2_delete_file_version — POST with fileName AND fileId (both required)
        public func deleteFileVersion(
            apiUrl: String,
            authToken: String,
            fileName: String,
            fileId: String
        ) async throws -> B2DeleteFileResponse

        // MARK: - Copy

        /// b2_copy_file — POST, server-side copy (max 5GB)
        public func copyFile(
            apiUrl: String,
            authToken: String,
            sourceFileId: String,
            destinationFileName: String,
            destinationBucketId: String? = nil
        ) async throws -> B2CopyFileResponse
    }
    ```

    Implementation details for each method:

    **authorizeAccount:**
    - URL: `https://api.backblazeb2.com/b2api/v4/b2_authorize_account`
    - Method: GET
    - Auth: Basic (base64 of `keyId:applicationKey`)
    - Headers: Authorization, User-Agent

    **listBuckets:**
    - URL: `{apiUrl}/b2api/v4/b2_list_buckets`
    - Method: POST
    - Body: JSON `{"accountId": "..."}`
    - Headers: Authorization (Bearer token), User-Agent

    **listFileNames:**
    - URL: `{apiUrl}/b2api/v4/b2_list_file_names?bucketId=X&prefix=X&delimiter=X&startFileName=X&maxFileCount=X`
    - Method: GET
    - Headers: Authorization, User-Agent
    - Query params must be URL-encoded

    **downloadFileByName:**
    - URL: `{downloadUrl}/file/{bucketName}/{fileName}`
    - Method: GET
    - fileName must be percent-encoded in the URL path
    - If range provided, add `Range: bytes={start}-{end}` header
    - Headers: Authorization, User-Agent, Range (optional)
    - Returns raw Data + HTTPURLResponse (not decoded — caller handles binary content)

    **getUploadUrl:**
    - URL: `{apiUrl}/b2api/v4/b2_get_upload_url?bucketId=X`
    - Method: GET
    - Headers: Authorization, User-Agent

    **uploadFile:**
    - URL: `{uploadUrl}` (from getUploadUrl response — NOT the apiUrl)
    - Method: POST
    - Auth: upload-specific token from getUploadUrl (NOT the account auth token)
    - Body: raw file bytes (NOT JSON)
    - Headers: Authorization (upload token), X-Bz-File-Name (percent-encoded), Content-Type, Content-Length, X-Bz-Content-Sha1, User-Agent
    - Optional: X-Bz-Info-src_last_modified_millis

    **deleteFileVersion:**
    - URL: `{apiUrl}/b2api/v4/b2_delete_file_version`
    - Method: POST
    - Body: JSON `{"fileName": "...", "fileId": "..."}`
    - Both fileName AND fileId are REQUIRED

    **copyFile:**
    - URL: `{apiUrl}/b2api/v4/b2_copy_file`
    - Method: POST
    - Body: JSON `{"sourceFileId": "...", "fileName": "..."}`
    - Optional: destinationBucketId

    **Shared helper methods:**
    - `validateResponse(_ response: URLResponse, data: Data) throws` — checks HTTP status, parses B2ErrorResponse on non-2xx, throws appropriate B2Error
    - All methods set `User-Agent` header to `B2Constants.userAgent`
    - For percent-encoding file names in URLs, use `addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)` — but be careful that B2 requires encoding of characters that URLPathAllowed normally allows (like `+`). Use a custom character set if needed.
    - For JSON body requests, set `Content-Type: application/json`
  </action>
  <verify>
    - `ls CloudMountKit/B2/B2HTTPClient.swift` — exists
    - `grep "func authorizeAccount" CloudMountKit/B2/B2HTTPClient.swift` — found
    - `grep "func listFileNames" CloudMountKit/B2/B2HTTPClient.swift` — found
    - `grep "func downloadFileByName" CloudMountKit/B2/B2HTTPClient.swift` — found
    - `grep "func getUploadUrl" CloudMountKit/B2/B2HTTPClient.swift` — found
    - `grep "func uploadFile" CloudMountKit/B2/B2HTTPClient.swift` — found
    - `grep "func deleteFileVersion" CloudMountKit/B2/B2HTTPClient.swift` — found
    - `grep "func copyFile" CloudMountKit/B2/B2HTTPClient.swift` — found
    - `grep "User-Agent\|userAgent" CloudMountKit/B2/B2HTTPClient.swift` — found
    - `xcodebuild -project CloudMount.xcodeproj -scheme CloudMountKit -configuration Debug build 2>&1 | tail -3` shows BUILD SUCCEEDED
  </verify>
  <done>B2HTTPClient exists with methods for all required B2 v4 endpoints (authorize, list buckets, list files, download, get upload URL, upload, delete, copy). All methods are async, use URLSession, and include proper headers. The client is stateless — no token management or caching.</done>
</task>

</tasks>

<verification>
1. CloudMountKit framework builds with B2Types.swift, B2Error.swift, and B2HTTPClient.swift
2. All 7 B2 API endpoints are mapped in B2HTTPClient (authorize, listBuckets, listFileNames, downloadFileByName, getUploadUrl, uploadFile, deleteFileVersion, copyFile = 8 methods)
3. FlexibleInt64 handles both Int64 and String-encoded numeric values
4. B2Error classifies errors as auth-expired vs retryable vs permanent
5. All public APIs are async/await
6. User-Agent header is set on all requests
</verification>

<success_criteria>
- B2Types.swift contains Codable models for all B2 v4 response types including FlexibleInt64
- B2Error.swift has typed error cases with isAuthExpired and isRetryable classification
- B2HTTPClient.swift maps 1:1 to all required B2 endpoints with correct HTTP methods, URLs, headers, and body encoding
- CloudMountKit framework compiles with all three files
</success_criteria>

<output>
After completion, create `.planning/phases/05-build-system-b2-client/05-03-SUMMARY.md`
</output>
