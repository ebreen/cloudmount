---
phase: 05-build-system-b2-client
plan: 04
type: execute
wave: 3
depends_on: ["05-02", "05-03"]
files_modified:
  - CloudMountKit/B2/B2AuthManager.swift
  - CloudMountKit/B2/B2Client.swift
  - CloudMountKit/Cache/MetadataCache.swift
  - CloudMountKit/Cache/FileCache.swift
autonomous: true

must_haves:
  truths:
    - "B2 auth tokens refresh automatically on 401 expired_auth_token/bad_auth_token without user intervention"
    - "B2Client provides high-level operations: list directory, download, upload, delete, copy, create folder"
    - "Directory listings are cached in memory with ~5 minute TTL and invalidated on local writes"
    - "Downloaded files are cached on disk in ~/Library/Caches/CloudMount/ with LRU eviction at 1GB default"
    - "All B2 operations automatically retry once on auth expiry after refreshing the token"
  artifacts:
    - path: "CloudMountKit/B2/B2AuthManager.swift"
      provides: "Token lifecycle actor with transparent refresh"
      contains: "actor B2AuthManager"
    - path: "CloudMountKit/B2/B2Client.swift"
      provides: "High-level B2 domain API with caching and auto-refresh"
      contains: "actor B2Client"
    - path: "CloudMountKit/Cache/MetadataCache.swift"
      provides: "In-memory TTL cache for directory listings"
      contains: "actor MetadataCache"
    - path: "CloudMountKit/Cache/FileCache.swift"
      provides: "On-disk LRU file cache"
      contains: "FileCache"
  key_links:
    - from: "B2Client"
      to: "B2HTTPClient"
      via: "Delegates all HTTP calls to low-level client"
      pattern: "http\\..*\\("
    - from: "B2Client"
      to: "B2AuthManager"
      via: "Gets current auth token, triggers refresh on 401"
      pattern: "authManager"
    - from: "B2Client"
      to: "MetadataCache"
      via: "Checks cache before listing, invalidates on writes"
      pattern: "metadataCache"
    - from: "B2Client"
      to: "FileCache"
      via: "Checks disk cache before download, stores after download"
      pattern: "fileCache"
    - from: "B2AuthManager"
      to: "B2HTTPClient.authorizeAccount"
      via: "Re-authenticates on token expiry"
      pattern: "authorizeAccount"
---

<objective>
Build the B2AuthManager (token lifecycle), MetadataCache (in-memory TTL), FileCache (on-disk LRU), and B2Client actor (high-level domain API that wires everything together). The B2Client provides convenient operations with transparent token refresh, caching, and pagination.

Purpose: Complete the B2 client stack so that callers can perform file operations with a single method call, without worrying about auth tokens, pagination, or caching.
Output: Four files completing the CloudMountKit B2 client — ready for FSKit integration in Phase 6 and UI wiring in Plan 05.
</objective>

<execution_context>
@~/.config/Claude/get-shit-done/workflows/execute-plan.md
@~/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-build-system-b2-client/05-RESEARCH.md
@.planning/phases/05-build-system-b2-client/05-CONTEXT.md
@.planning/phases/05-build-system-b2-client/05-02-SUMMARY.md
@.planning/phases/05-build-system-b2-client/05-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: B2AuthManager + MetadataCache + FileCache</name>
  <files>
    CloudMountKit/B2/B2AuthManager.swift
    CloudMountKit/Cache/MetadataCache.swift
    CloudMountKit/Cache/FileCache.swift
  </files>
  <action>
    Create three supporting components that B2Client depends on:

    **1. `CloudMountKit/B2/B2AuthManager.swift` — Token lifecycle actor:**

    ```swift
    public actor B2AuthManager {
        // Auth state (populated after authorize)
        public private(set) var authToken: String
        public private(set) var apiUrl: String
        public private(set) var downloadUrl: String
        public private(set) var accountId: String
        public private(set) var recommendedPartSize: Int
        public private(set) var absoluteMinimumPartSize: Int
        public private(set) var allowed: B2Allowed

        private let keyId: String
        private let applicationKey: String
        private let http: B2HTTPClient

        public init(keyId: String, applicationKey: String, http: B2HTTPClient = B2HTTPClient()) async throws {
            // Store credentials for refresh
            // Call authorizeAccount immediately to populate state
            // Throw if initial auth fails
        }

        /// Re-authenticate to get fresh token. Called on 401 auth errors.
        public func refresh() async throws {
            let response = try await http.authorizeAccount(keyId: keyId, applicationKey: applicationKey)
            self.authToken = response.authorizationToken
            self.apiUrl = response.apiInfo.storageApi.apiUrl
            self.downloadUrl = response.apiInfo.storageApi.downloadUrl
            self.accountId = response.accountId
            self.recommendedPartSize = response.apiInfo.storageApi.recommendedPartSize
            self.absoluteMinimumPartSize = response.apiInfo.storageApi.absoluteMinimumPartSize
            self.allowed = response.apiInfo.storageApi.allowed
        }
    }
    ```

    The init should call `authorizeAccount` and populate all fields. If the initial auth fails, throw — don't create a half-initialized manager.

    **2. `CloudMountKit/Cache/MetadataCache.swift` — In-memory TTL cache:**

    An actor-isolated dictionary-based cache with configurable TTL (default 5 minutes / 300 seconds).

    ```swift
    public actor MetadataCache {
        private struct CacheEntry<T> {
            let value: T
            let expiresAt: Date
            var isExpired: Bool { Date() > expiresAt }
        }

        private var directoryListings: [String: CacheEntry<[B2FileInfo]>] = [:]
        private var fileMetadata: [String: CacheEntry<B2FileInfo>] = [:]
        private let ttl: TimeInterval

        public init(ttl: TimeInterval = 300) { self.ttl = ttl }

        // Directory listings
        public func getDirectoryListing(bucketId: String, path: String) -> [B2FileInfo]?
        public func cacheDirectoryListing(bucketId: String, path: String, entries: [B2FileInfo])

        // Single file metadata
        public func getFileMetadata(bucketId: String, fileName: String) -> B2FileInfo?
        public func cacheFileMetadata(bucketId: String, fileName: String, info: B2FileInfo)

        // Invalidation
        public func invalidate(bucketId: String, path: String)   // Invalidates path AND its parent directory
        public func invalidateAll(bucketId: String)               // Clears all entries for a bucket
        public func clearAll()                                     // Nuclear option
    }
    ```

    Cache key format: `"{bucketId}:{path}"`. Invalidation of a path also invalidates the parent directory (because a write in a subdirectory changes the parent's listing).

    **3. `CloudMountKit/Cache/FileCache.swift` — On-disk LRU file cache:**

    Stores downloaded file content on disk to avoid re-fetching. Uses `~/Library/Caches/CloudMount/` as the base directory.

    ```swift
    public actor FileCache {
        private let cacheDirectory: URL
        private let maxSizeBytes: Int64
        private var entries: [String: FileCacheEntry] = [:]    // fileName -> entry

        private struct FileCacheEntry {
            let localPath: URL
            let sizeBytes: Int64
            var lastAccessed: Date
        }

        public init(maxSizeBytes: Int64 = 1_073_741_824) {   // 1 GB default
            let cacheDir = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).first!
                .appendingPathComponent("CloudMount", isDirectory: true)
            self.cacheDirectory = cacheDir
            self.maxSizeBytes = maxSizeBytes
            // Create directory if needed
            try? FileManager.default.createDirectory(at: cacheDir, withIntermediateDirectories: true)
            // Scan existing cache on init
        }

        /// Get cached file data, returns nil if not cached
        public func get(bucketName: String, fileName: String) -> Data?

        /// Store file data in cache, evicting LRU if over size limit
        public func store(bucketName: String, fileName: String, data: Data)

        /// Remove a specific cached file (call on delete/overwrite)
        public func remove(bucketName: String, fileName: String)

        /// Clear entire cache
        public func clearAll()

        /// Current total cache size in bytes
        public var currentSizeBytes: Int64 { ... }
    }
    ```

    Cache file path: `~/Library/Caches/CloudMount/{bucketName}/{fileName}` — create intermediate directories as needed. Use SHA-256 hash of fileName as the disk filename to avoid path issues.

    LRU eviction: when storing a new file would exceed `maxSizeBytes`, evict the least-recently-accessed entries until there's room. Track access times in `FileCacheEntry`.

    All three types must be `public`.
  </action>
  <verify>
    - `ls CloudMountKit/B2/B2AuthManager.swift CloudMountKit/Cache/MetadataCache.swift CloudMountKit/Cache/FileCache.swift` — all exist
    - `grep "actor B2AuthManager" CloudMountKit/B2/B2AuthManager.swift` — found
    - `grep "func refresh" CloudMountKit/B2/B2AuthManager.swift` — found
    - `grep "actor MetadataCache" CloudMountKit/Cache/MetadataCache.swift` — found
    - `grep "func invalidate" CloudMountKit/Cache/MetadataCache.swift` — found
    - `grep "FileCache" CloudMountKit/Cache/FileCache.swift` — found
    - `grep "Library/Caches/CloudMount\|cachesDirectory" CloudMountKit/Cache/FileCache.swift` — found
    - `xcodebuild -project CloudMount.xcodeproj -scheme CloudMountKit -configuration Debug build 2>&1 | tail -3` shows BUILD SUCCEEDED
  </verify>
  <done>B2AuthManager handles token lifecycle with refresh. MetadataCache provides in-memory TTL caching for directory listings. FileCache provides on-disk LRU caching for downloaded files. All three compile as part of CloudMountKit.</done>
</task>

<task type="auto">
  <name>Task 2: B2Client actor — high-level domain API wiring everything together</name>
  <files>
    CloudMountKit/B2/B2Client.swift
  </files>
  <action>
    Create `CloudMountKit/B2/B2Client.swift` — the high-level B2 client actor that provides convenient domain operations. This actor owns B2HTTPClient, B2AuthManager, MetadataCache, and FileCache, and wires them together with transparent token refresh and caching.

    ```swift
    public actor B2Client {
        private let http: B2HTTPClient
        private let authManager: B2AuthManager
        private let metadataCache: MetadataCache
        private let fileCache: FileCache

        /// Create a B2Client by authenticating with the given credentials.
        /// Throws if authentication fails.
        public init(keyId: String, applicationKey: String, cacheSettings: CacheSettings = CacheSettings()) async throws {
            self.http = B2HTTPClient()
            self.authManager = try await B2AuthManager(keyId: keyId, applicationKey: applicationKey, http: http)
            self.metadataCache = MetadataCache(ttl: TimeInterval(cacheSettings.metadataTTLSeconds))
            self.fileCache = FileCache(maxSizeBytes: cacheSettings.maxFileCacheSizeBytes)
        }
    }
    ```

    **withAutoRefresh helper:** A private method that executes an operation and retries ONCE on auth expiry:
    ```swift
    private func withAutoRefresh<T>(_ operation: @Sendable () async throws -> T) async throws -> T {
        do {
            return try await operation()
        } catch let error as B2Error where error.isAuthExpired {
            try await authManager.refresh()
            return try await operation()
        }
    }
    ```

    Note: Because B2Client is an actor, the closure needs careful handling of actor isolation. The operation closures call `self.http` methods which are Sendable (B2HTTPClient is a struct). The auth token/apiUrl come from authManager (also an actor). Ensure the closure captures the token values BEFORE the call, not the actor references.

    Actually, the pattern should be:
    ```swift
    private func withAutoRefresh<T>(_ operation: (String, String, String) async throws -> T) async throws -> T {
        // First attempt with current tokens
        let token = await authManager.authToken
        let apiUrl = await authManager.apiUrl
        let downloadUrl = await authManager.downloadUrl
        do {
            return try await operation(token, apiUrl, downloadUrl)
        } catch let error as B2Error where error.isAuthExpired {
            try await authManager.refresh()
            let newToken = await authManager.authToken
            let newApiUrl = await authManager.apiUrl
            let newDownloadUrl = await authManager.downloadUrl
            return try await operation(newToken, newApiUrl, newDownloadUrl)
        }
    }
    ```

    Or simplify: create a helper struct for auth context:
    ```swift
    private struct AuthContext {
        let token: String
        let apiUrl: String
        let downloadUrl: String
        let accountId: String
    }

    private func currentAuth() async -> AuthContext {
        await AuthContext(
            token: authManager.authToken,
            apiUrl: authManager.apiUrl,
            downloadUrl: authManager.downloadUrl,
            accountId: authManager.accountId
        )
    }
    ```

    **Required high-level operations:**

    1. **`listBuckets() async throws -> [B2BucketInfo]`**
       - Uses account auth to list all accessible buckets
       - Useful for credential validation and bucket selection UI

    2. **`listDirectory(bucketId: String, path: String) async throws -> [B2FileInfo]`**
       - Check MetadataCache first
       - If miss: call listFileNames with prefix=path, delimiter="/"
       - Handle pagination: loop until nextFileName is nil
       - Cache result in MetadataCache
       - Return array of B2FileInfo entries

    3. **`downloadFile(bucketName: String, fileName: String, range: ClosedRange<Int64>? = nil) async throws -> Data`**
       - For full downloads (range == nil): check FileCache first
       - If miss: call downloadFileByName
       - Store in FileCache for full downloads
       - Return Data

    4. **`uploadFile(bucketId: String, bucketName: String, fileName: String, data: Data, contentType: String = "b2/x-auto", lastModifiedMillis: Int64? = nil) async throws -> B2UploadFileResponse`**
       - Calculate SHA-1 of data using CryptoKit (NOT SHA-256 — B2 requires SHA-1 for uploads!)
       - Get upload URL (getUploadUrl)
       - Upload file (uploadFile with upload-specific token)
       - On upload failure (401, 408, 500+): get NEW upload URL and retry
       - Invalidate MetadataCache for the file's parent directory
       - Invalidate FileCache for this fileName (in case of overwrite)
       - Return upload response

       IMPORTANT: Use `Insecure.SHA1` from CryptoKit for the upload checksum. B2 requires SHA-1, not SHA-256. The header is `X-Bz-Content-Sha1`.

    5. **`deleteFile(fileName: String, fileId: String) async throws`**
       - Call deleteFileVersion with both fileName and fileId
       - Invalidate MetadataCache for the file's parent directory
       - Remove from FileCache

    6. **`copyFile(sourceFileId: String, destinationFileName: String, destinationBucketId: String? = nil) async throws -> B2CopyFileResponse`**
       - Call copyFile on HTTP client
       - Invalidate MetadataCache for the destination file's parent directory
       - Return copy response

    7. **`createFolder(bucketId: String, bucketName: String, folderPath: String) async throws`**
       - Ensure folderPath ends with "/"
       - Upload zero-byte file with contentType "application/x-directory"
       - SHA-1 of empty data: "da39a3ee5e6b4b0d3255bfef95601890afd80709" (B2Constants.emptySHA1)
       - Invalidate MetadataCache for the parent directory

    8. **`rename(sourceFileName: String, sourceFileId: String, destinationFileName: String, bucketId: String) async throws`**
       - Copy file to new name (copyFile)
       - Delete original (deleteFile)
       - Invalidate caches for both source and destination parent directories
       - NOTE: This only works for files ≤5GB. Log a warning or throw a specific error for larger files.

    **Cache invalidation strategy:**
    - All write operations (upload, delete, copy, createFolder, rename) must invalidate the MetadataCache for the affected directory AND its parent.
    - Upload/delete also invalidate FileCache for the affected file.
    - Use a helper: `invalidateCachesForPath(bucketId:fileName:)` that computes the parent directory path and calls `metadataCache.invalidate()`.

    **Import CryptoKit** for SHA-1 hash computation in upload.

    All methods must be `public`.
  </action>
  <verify>
    - `ls CloudMountKit/B2/B2Client.swift` — exists
    - `grep "actor B2Client" CloudMountKit/B2/B2Client.swift` — found
    - `grep "func listDirectory" CloudMountKit/B2/B2Client.swift` — found
    - `grep "func downloadFile" CloudMountKit/B2/B2Client.swift` — found
    - `grep "func uploadFile" CloudMountKit/B2/B2Client.swift` — found
    - `grep "func deleteFile" CloudMountKit/B2/B2Client.swift` — found
    - `grep "func copyFile" CloudMountKit/B2/B2Client.swift` — found
    - `grep "func createFolder" CloudMountKit/B2/B2Client.swift` — found
    - `grep "func rename" CloudMountKit/B2/B2Client.swift` — found
    - `grep "import CryptoKit" CloudMountKit/B2/B2Client.swift` — found
    - `grep "Insecure.SHA1\|SHA1" CloudMountKit/B2/B2Client.swift` — found (SHA-1 for upload)
    - `grep "metadataCache\\.invalidate\|invalidateCache" CloudMountKit/B2/B2Client.swift` — found (cache invalidation on writes)
    - `xcodebuild -project CloudMount.xcodeproj -scheme CloudMountKit -configuration Debug build 2>&1 | tail -3` shows BUILD SUCCEEDED
  </verify>
  <done>B2Client actor provides all high-level B2 operations with transparent token refresh, metadata caching, file caching, pagination handling, and cache invalidation on writes. Complete B2 client stack compiles as part of CloudMountKit.</done>
</task>

</tasks>

<verification>
1. CloudMountKit framework builds with all B2 and Cache files
2. B2AuthManager authenticates on init and supports token refresh
3. B2Client provides all 8 high-level operations (listBuckets, listDirectory, downloadFile, uploadFile, deleteFile, copyFile, createFolder, rename)
4. MetadataCache has TTL-based expiration with per-path invalidation
5. FileCache stores files on disk with LRU eviction
6. All write operations invalidate relevant cache entries
7. Token refresh is transparent — retries once on auth expiry
8. Upload uses SHA-1 (not SHA-256) via CryptoKit's Insecure.SHA1
</verification>

<success_criteria>
- B2Client can authenticate, list, download, upload, delete, copy, and create folders through its high-level API
- Token refresh happens automatically on 401 auth expiry errors
- MetadataCache reduces redundant list API calls with ~5 min TTL
- FileCache stores downloaded files on disk to avoid re-fetching
- Cache invalidation fires on all write operations
- CloudMountKit framework compiles with the complete B2 client stack
</success_criteria>

<output>
After completion, create `.planning/phases/05-build-system-b2-client/05-04-SUMMARY.md`
</output>
