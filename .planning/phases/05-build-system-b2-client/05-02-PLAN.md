---
phase: 05-build-system-b2-client
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - CloudMountKit/Credentials/CredentialStore.swift
  - CloudMountKit/Credentials/AccountConfig.swift
  - CloudMountKit/Credentials/MountConfig.swift
  - CloudMountKit/Config/SharedDefaults.swift
autonomous: true

must_haves:
  truths:
    - "Multiple B2 accounts can be stored and retrieved independently"
    - "Credentials are stored in Keychain with shared access group for cross-process access"
    - "Non-secret config (mount settings, cache prefs) stored in App Group UserDefaults"
    - "Account and mount config models support multi-account, multi-mount from the start"
  artifacts:
    - path: "CloudMountKit/Credentials/CredentialStore.swift"
      provides: "Native Keychain CRUD with shared access group"
      contains: "kSecAttrAccessGroup"
    - path: "CloudMountKit/Credentials/AccountConfig.swift"
      provides: "B2Account model with Codable, UUID id, label"
      contains: "struct B2Account"
    - path: "CloudMountKit/Credentials/MountConfig.swift"
      provides: "MountConfiguration and CacheSettings models"
      contains: "struct MountConfiguration"
    - path: "CloudMountKit/Config/SharedDefaults.swift"
      provides: "App Group UserDefaults wrapper"
      contains: "group.com.cloudmount.shared"
  key_links:
    - from: "CredentialStore"
      to: "Security.framework"
      via: "SecItemAdd/SecItemCopyMatching with kSecAttrAccessGroup"
      pattern: "SecItem"
    - from: "SharedDefaults"
      to: "UserDefaults(suiteName:)"
      via: "App Group suite name"
      pattern: "group\\.com\\.cloudmount\\.shared"
---

<objective>
Build the credential storage and configuration model layer in CloudMountKit using native Security.framework for Keychain access (replacing the KeychainAccess SPM package) and App Group UserDefaults for non-secret config. Models support multiple B2 accounts and multiple mount configurations from the start.

Purpose: Establish secure, cross-process credential sharing between host app and FSKit extension, with a multi-account data model that subsequent plans (B2 client, UI) build on.
Output: Four files in CloudMountKit providing credential CRUD, account models, mount config models, and shared defaults.
</objective>

<execution_context>
@~/.config/Claude/get-shit-done/workflows/execute-plan.md
@~/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-build-system-b2-client/05-RESEARCH.md
@.planning/phases/05-build-system-b2-client/05-CONTEXT.md
@.planning/phases/05-build-system-b2-client/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Native Keychain credential store with shared access group</name>
  <files>
    CloudMountKit/Credentials/CredentialStore.swift
  </files>
  <action>
    Create `CloudMountKit/Credentials/CredentialStore.swift` — a native Keychain wrapper using Security.framework directly (NOT the KeychainAccess SPM package).

    Requirements:
    1. Use `kSecAttrAccessGroup` set to `$(AppIdentifierPrefix)com.cloudmount.shared` for cross-process sharing. Store the access group as a static constant. NOTE: The `$(AppIdentifierPrefix)` is resolved at build time by Xcode from the entitlements. At runtime, use the actual team ID prefix. For development, pass the access group as a parameter or use a computed property that reads from the app's entitlements. A practical approach: define the constant as a string and let the entitlements handle resolution, OR use `nil` for access group during development (uses default group) and the explicit group for production. The simplest approach that works: use the string `"$(AppIdentifierPrefix)com.cloudmount.shared"` — Xcode will NOT resolve this at runtime. Instead, omit the access group in code and rely on the entitlements file declaring it, which makes the default access group include the shared one. Alternatively, hardcode the team ID prefix — but that's fragile.

    **Recommended approach:** Define a `KeychainHelper` struct with these operations:
    - `save(data:service:account:)` — save Data to Keychain (delete-then-add pattern)
    - `load(service:account:)` -> Data? — retrieve Data from Keychain
    - `delete(service:account:)` — remove from Keychain
    - `listAccounts(service:)` -> [String] — list all account keys for a service

    Use `kSecClassGenericPassword` for all items. Set `kSecAttrAccessible` to `kSecAttrAccessibleWhenUnlocked`.

    For the access group: use a configurable static property. In entitlements, both app and extension declare the same `keychain-access-groups`, which means they can both access items saved with that group. In code, include `kSecAttrAccessGroup` in queries to explicitly target the shared group. Use the team-id-prefixed string — the actual team ID will be known at build time. For now, define:
    ```swift
    static var accessGroup: String? = nil  // Uses default; set to "TEAMID.com.cloudmount.shared" when team ID is known
    ```
    Only include `kSecAttrAccessGroup` in the query dictionary when `accessGroup` is non-nil.

    2. Build a higher-level `CredentialStore` that uses `KeychainHelper` to manage B2 accounts:
    - `saveAccount(_ account: B2Account)` — stores the account's keyId and applicationKey in Keychain, keyed by account UUID
    - `loadAccount(id: UUID) -> B2Account?` — retrieves a stored account
    - `loadAllAccounts() -> [B2Account]` — lists all stored accounts
    - `deleteAccount(id: UUID)` — removes account credentials
    - Service name: `"com.cloudmount.b2"` (constant)

    The B2Account struct has `keyId` and `applicationKey` as stored Keychain values. The account metadata (id, label, accountId, lastAuthorized) is stored in UserDefaults via SharedDefaults (from Task 2), NOT in Keychain. Only secrets go in Keychain.

    So CredentialStore stores: a JSON blob of `{keyId, applicationKey}` keyed by the account UUID string.

    3. Error handling: define a `KeychainError` enum with cases for common SecItem status codes (errSecDuplicateItem, errSecItemNotFound, errSecAuthFailed, etc.) with the raw OSStatus attached.

    4. Mark the struct as `public` so it's accessible from the host app target.

    Do NOT import KeychainAccess. Use only `import Foundation` and `import Security`.
  </action>
  <verify>
    - File exists at `CloudMountKit/Credentials/CredentialStore.swift`
    - `grep "import Security" CloudMountKit/Credentials/CredentialStore.swift` finds the import
    - `grep "KeychainAccess" CloudMountKit/Credentials/CredentialStore.swift | wc -l` returns 0 (no SPM dependency)
    - `grep "SecItemAdd\|SecItemCopyMatching\|SecItemDelete" CloudMountKit/Credentials/CredentialStore.swift | wc -l` returns at least 3
    - `xcodebuild -project CloudMount.xcodeproj -scheme CloudMountKit -configuration Debug build 2>&1 | tail -3` shows BUILD SUCCEEDED
  </verify>
  <done>Native Keychain credential store exists using Security.framework with shared access group support, stores B2 credentials keyed by account UUID, and compiles as part of CloudMountKit framework.</done>
</task>

<task type="auto">
  <name>Task 2: Account config, mount config, and shared defaults models</name>
  <files>
    CloudMountKit/Credentials/AccountConfig.swift
    CloudMountKit/Credentials/MountConfig.swift
    CloudMountKit/Config/SharedDefaults.swift
  </files>
  <action>
    Create three model files in CloudMountKit:

    **1. `CloudMountKit/Credentials/AccountConfig.swift`:**

    ```swift
    public struct B2Account: Identifiable, Codable, Hashable {
        public let id: UUID
        public var label: String                    // User-friendly name ("Personal", "Work")
        public var keyId: String                    // NOT stored here at rest — only in Keychain
        public var accountId: String?               // Populated after first successful auth
        public var lastAuthorized: Date?            // Timestamp of last successful auth

        public init(id: UUID = UUID(), label: String, keyId: String, accountId: String? = nil, lastAuthorized: Date? = nil) { ... }
    }
    ```

    IMPORTANT: The `keyId` field is stored in the model for display/reference purposes (it's not a secret — it's like a username). The actual `applicationKey` (the secret) is ONLY in Keychain via CredentialStore. The B2Account model stored in UserDefaults contains id, label, keyId, accountId, lastAuthorized. The applicationKey is retrieved from Keychain when needed.

    **2. `CloudMountKit/Credentials/MountConfig.swift`:**

    ```swift
    public struct MountConfiguration: Identifiable, Codable, Hashable {
        public let id: UUID
        public var accountId: UUID                  // References B2Account.id
        public var bucketId: String                 // B2 bucket ID
        public var bucketName: String               // B2 bucket name (for display + download URLs)
        public var mountPoint: String               // e.g. "/Volumes/my-bucket"
        public var autoMount: Bool                  // Mount automatically on launch
        public var cacheSettings: CacheSettings

        public init(...) { ... }
    }

    public struct CacheSettings: Codable, Hashable {
        public var metadataTTLSeconds: Int = 300           // 5 minutes
        public var maxFileCacheSizeBytes: Int64 = 1_073_741_824  // 1 GB
        public var enableFileCache: Bool = true

        public init(...) { ... }
    }
    ```

    **3. `CloudMountKit/Config/SharedDefaults.swift`:**

    A wrapper around `UserDefaults(suiteName: "group.com.cloudmount.shared")` for storing non-secret config shared between app and extension.

    ```swift
    public final class SharedDefaults {
        public static let shared = SharedDefaults()

        private let defaults: UserDefaults

        private init() {
            // App Group suite name — shared between host app and extension
            self.defaults = UserDefaults(suiteName: "group.com.cloudmount.shared") ?? .standard
        }

        // MARK: - Accounts (metadata only, secrets in Keychain)
        public func saveAccounts(_ accounts: [B2Account]) { ... }
        public func loadAccounts() -> [B2Account] { ... }

        // MARK: - Mount Configurations
        public func saveMountConfigurations(_ configs: [MountConfiguration]) { ... }
        public func loadMountConfigurations() -> [MountConfiguration] { ... }

        // MARK: - General Settings
        public var launchAtLogin: Bool { get/set }
    }
    ```

    Use JSON encoding/decoding for storing arrays of Codable structs in UserDefaults. Keys should be namespaced: `"cloudmount.accounts"`, `"cloudmount.mounts"`, `"cloudmount.launchAtLogin"`.

    All types must be `public` for cross-target access. All types must conform to `Codable` and `Hashable`.
  </action>
  <verify>
    - `ls CloudMountKit/Credentials/AccountConfig.swift CloudMountKit/Credentials/MountConfig.swift CloudMountKit/Config/SharedDefaults.swift` — all three exist
    - `grep "public struct B2Account" CloudMountKit/Credentials/AccountConfig.swift` — found
    - `grep "public struct MountConfiguration" CloudMountKit/Credentials/MountConfig.swift` — found
    - `grep "group.com.cloudmount.shared" CloudMountKit/Config/SharedDefaults.swift` — found
    - `xcodebuild -project CloudMount.xcodeproj -scheme CloudMountKit -configuration Debug build 2>&1 | tail -3` shows BUILD SUCCEEDED
  </verify>
  <done>B2Account, MountConfiguration, CacheSettings models exist with multi-account/multi-mount support. SharedDefaults provides App Group UserDefaults access. All types are public, Codable, and compile as part of CloudMountKit.</done>
</task>

</tasks>

<verification>
1. CloudMountKit framework builds successfully with all 4 new files
2. No reference to KeychainAccess SPM package in any file
3. CredentialStore uses native Security.framework (SecItemAdd, SecItemCopyMatching, SecItemDelete)
4. B2Account model has UUID id, label, keyId fields
5. MountConfiguration model references accountId (UUID) for multi-account support
6. SharedDefaults uses App Group suite name "group.com.cloudmount.shared"
</verification>

<success_criteria>
- CloudMountKit compiles with credential store, account config, mount config, and shared defaults
- Keychain operations use Security.framework directly, not a third-party wrapper
- Models support multiple accounts and multiple mount configurations
- SharedDefaults uses App Group UserDefaults for cross-process config sharing
</success_criteria>

<output>
After completion, create `.planning/phases/05-build-system-b2-client/05-02-SUMMARY.md`
</output>
