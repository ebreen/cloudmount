---
phase: 06-fskit-filesystem
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - CloudMountExtension/CloudMountExtension.swift
  - CloudMountExtension/CloudMountFileSystem.swift
  - CloudMountExtension/B2Volume.swift
  - CloudMountExtension/Info.plist
  - project.yml
autonomous: true

must_haves:
  truths:
    - "Extension has a @main entry point that creates the filesystem delegate"
    - "FileSystem probes FSGenericURLResource and returns recognized"
    - "FileSystem loads a resource by parsing URL, creating B2Client, and returning a B2Volume"
    - "B2Volume returns root item and attributes on mount"
    - "Volume statistics return reasonable values for a cloud volume"
  artifacts:
    - path: "CloudMountExtension/CloudMountExtension.swift"
      provides: "@main entry point conforming to UnaryFileSystemExtension"
      contains: "@main"
    - path: "CloudMountExtension/CloudMountFileSystem.swift"
      provides: "FSUnaryFileSystem subclass with probe/load/unload lifecycle"
      contains: "class CloudMountFileSystem"
    - path: "CloudMountExtension/B2Volume.swift"
      provides: "FSVolume subclass shell with mount/unmount/activate/deactivate/pathconf/volumeStatistics"
      contains: "class B2Volume: FSVolume"
    - path: "CloudMountExtension/Info.plist"
      provides: "Extension Info.plist with FSSupportedSchemes for b2:// URL scheme"
      contains: "FSSupportedSchemes"
  key_links:
    - from: "CloudMountExtension/CloudMountExtension.swift"
      to: "CloudMountExtension/CloudMountFileSystem.swift"
      via: "entry point creates filesystem instance"
      pattern: "CloudMountFileSystem()"
    - from: "CloudMountExtension/CloudMountFileSystem.swift"
      to: "CloudMountExtension/B2Volume.swift"
      via: "loadResource creates and returns B2Volume"
      pattern: "B2Volume("
    - from: "CloudMountExtension/CloudMountFileSystem.swift"
      to: "CloudMountKit/B2/B2Client.swift"
      via: "loadResource creates B2Client from credentials"
      pattern: "B2Client("
---

<objective>
Create the FSKit extension entry point, filesystem lifecycle handler, and B2Volume shell class. After this plan, the extension has a working @main entry, handles probe/load/unload lifecycle for b2:// URLs, and returns a volume with root item on mount.

Purpose: This is the structural skeleton that macOS/FSKit interacts with. Without this, no filesystem operations can happen. The volume shell establishes the class hierarchy that Plans 03 and 04 fill in with operations.

Output: CloudMountExtension.swift (@main), CloudMountFileSystem.swift (lifecycle), B2Volume.swift (volume base), updated Info.plist with FSSupportedSchemes.
</objective>

<execution_context>
@~/.config/Claude/get-shit-done/workflows/execute-plan.md
@~/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-fskit-filesystem/06-RESEARCH.md
@.planning/phases/06-fskit-filesystem/06-CONTEXT.md
@.planning/phases/06-fskit-filesystem/06-01-SUMMARY.md
@CloudMountKit/B2/B2Client.swift
@CloudMountKit/B2/B2AuthManager.swift
@CloudMountKit/Credentials/CredentialStore.swift
@CloudMountKit/Config/SharedDefaults.swift
@CloudMountKit/Credentials/MountConfig.swift
@CloudMountExtension/CloudMountExtension.swift
@CloudMountExtension/Info.plist
@project.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extension entry point + FileSystem lifecycle + Info.plist</name>
  <files>CloudMountExtension/CloudMountExtension.swift, CloudMountExtension/CloudMountFileSystem.swift, CloudMountExtension/Info.plist, project.yml</files>
  <action>
**Replace** the stub `CloudMountExtension/CloudMountExtension.swift` with the @main entry point:

```swift
import FSKit

@main
struct CloudMountExtensionMain: UnaryFileSystemExtension {
    let fileSystem = CloudMountFileSystem()
}
```

Note: The current file has `class CloudMountExtension` — this must be fully replaced. The `NSExtensionPrincipalClass` in Info.plist currently references `CloudMountExtension` — it must be updated to reference the @main struct. In FSKit, the @main attribute handles the entry point, so update Info.plist's `NSExtensionPrincipalClass` to `$(PRODUCT_MODULE_NAME).CloudMountExtensionMain`.

**Create** `CloudMountExtension/CloudMountFileSystem.swift`:

```swift
import FSKit
import CloudMountKit
import os
```

Class `CloudMountFileSystem: FSUnaryFileSystem, FSUnaryFileSystemOperations`:

- Private logger: `private let logger = Logger(subsystem: "com.cloudmount.extension", category: "FileSystem")`

- `func probeResource(resource: FSResource, replyHandler: (FSProbeResult?, (any Error)?) -> Void)`:
  - Check `resource is FSGenericURLResource`
  - If not: reply with `FSProbeResult(result: .notRecognized, name: nil), nil`
  - If yes: reply with `FSProbeResult(result: .recognized, name: nil), nil`
  - Log the probe attempt

- `func loadResource(resource: FSResource, options: FSTaskOptions, replyHandler: (FSVolume?, (any Error)?) -> Void)`:
  - Guard cast to `FSGenericURLResource`, else reply with `nil, fs_errorForPOSIXError(EINVAL)`
  - Parse the URL: expect format `b2://bucketName?accountId=UUID` where the UUID references a B2Account in SharedDefaults/CredentialStore
  - Extract `bucketName` from URL host, `accountId` UUID from query parameter
  - Look up the MountConfiguration from SharedDefaults matching the bucketName + accountId
  - Load credentials from CredentialStore using the accountId UUID
  - Use `Task {}` to bridge to async:
    ```swift
    Task {
        do {
            let client = try await B2Client(keyId: creds.keyId, applicationKey: creds.applicationKey, cacheSettings: mountConfig.cacheSettings)
            // Look up bucketId from the mount config
            let volumeID = FSVolume.Identifier(/* use mount config id UUID */)
            let volumeName = FSFileName(string: bucketName)
            let volume = B2Volume(
                volumeID: volumeID,
                volumeName: volumeName,
                b2Client: client,
                bucketId: mountConfig.bucketId,
                bucketName: bucketName,
                mountId: mountConfig.id.uuidString
            )
            replyHandler(volume, nil)
        } catch {
            self.logger.error("Failed to load resource: \(error)")
            replyHandler(nil, error)
        }
    }
    ```
  - Important: replyHandler is called exactly once, from within the Task

- `func unloadResource(resource: FSResource, options: FSTaskOptions, replyHandler: ((any Error)?) -> Void)`:
  - Log the unload
  - Reply nil (cleanup happens in B2Volume.unmount)

- `func didFinishLoading()`:
  - Log that loading is complete

**Update** `CloudMountExtension/Info.plist`:
- Change `NSExtensionPrincipalClass` value from `$(PRODUCT_MODULE_NAME).CloudMountExtension` to `$(PRODUCT_MODULE_NAME).CloudMountExtensionMain`
- Add `FSSupportedSchemes` array under the `NSExtension` dict with one entry: `b2`

The Info.plist NSExtension dict should look like:
```xml
<key>NSExtension</key>
<dict>
    <key>NSExtensionPointIdentifier</key>
    <string>com.apple.filesystems.fs-module</string>
    <key>NSExtensionPrincipalClass</key>
    <string>$(PRODUCT_MODULE_NAME).CloudMountExtensionMain</string>
    <key>FSSupportedSchemes</key>
    <array>
        <string>b2</string>
    </array>
</dict>
```

**Update** `project.yml` if needed: ensure the CloudMountExtension target has `PRODUCT_BUNDLE_IDENTIFIER` and framework linkage to FSKit. The extension should already link CloudMountKit. Add `FSKit` to the extension's frameworks if not already implicit (FSKit is a system framework, may be auto-linked via `import FSKit`). Check if explicit framework linkage is needed in project.yml — if `import FSKit` works without it, no change needed.
  </action>
  <verify>Build the extension target: `xcodebuild -scheme CloudMount build CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO 2>&1 | tail -10` — should compile (may warn about unimplemented protocol methods on B2Volume, which is expected since B2Volume is created in Task 2)</verify>
  <done>Extension has @main entry creating CloudMountFileSystem; lifecycle methods handle probe/load/unload; Info.plist declares b2:// scheme support</done>
</task>

<task type="auto">
  <name>Task 2: B2Volume shell class with mount/unmount and volume metadata</name>
  <files>CloudMountExtension/B2Volume.swift</files>
  <action>
Create `CloudMountExtension/B2Volume.swift` — the FSVolume subclass that will hold all volume operations.

```swift
import FSKit
import CloudMountKit
import os
```

Class `B2Volume: FSVolume` conforming to:
- `FSVolume.Operations`
- `FSVolume.PathConfOperations`
- `FSVolume.OpenCloseOperations`
- `FSVolume.ReadWriteOperations`

**Important concurrency note:** FSKit calls volume methods from its own dispatch queue. B2Client is an actor. Use `Task {}` inside every method that needs to call B2Client async methods. The volume itself should NOT be an actor (it's an NSObject subclass via FSVolume).

Properties:
- `let b2Client: B2Client` — the B2 API client (actor, thread-safe)
- `let bucketId: String`
- `let bucketName: String`
- `private let stagingManager: StagingManager`
- `private let logger = Logger(subsystem: "com.cloudmount.extension", category: "Volume")`
- `private var itemCache: [String: B2Item] = [:]` — B2 path → cached B2Item (prevents duplicate FSItem instances)
- `private var nextItemId: UInt64 = 2` — monotonically increasing item IDs (1 reserved for root)
- `let rootItem: B2Item` — the root directory item

Init:
```swift
init(volumeID: FSVolume.Identifier, volumeName: FSFileName,
     b2Client: B2Client, bucketId: String, bucketName: String, mountId: String) {
    self.b2Client = b2Client
    self.bucketId = bucketId
    self.bucketName = bucketName
    self.stagingManager = StagingManager(mountId: mountId)
    
    // Create root item
    self.rootItem = B2Item(
        name: FSFileName(string: bucketName),
        identifier: .number(1),
        b2Path: "",
        bucketId: bucketId,
        isDirectory: true
    )
    
    super.init(volumeID: volumeID, volumeName: volumeName)
    
    // Cache root
    itemCache[""] = rootItem
}
```

Helper to generate unique item IDs:
```swift
private func allocateItemId() -> FSItem.Identifier {
    let id = nextItemId
    nextItemId += 1
    return .number(id)
}
```

Helper to get or create cached B2Item:
```swift
func cachedItem(for b2Path: String) -> B2Item? {
    return itemCache[b2Path]
}

func cacheItem(_ item: B2Item) {
    itemCache[item.b2Path] = item
}

func removeCachedItem(for b2Path: String) {
    itemCache.removeValue(forKey: b2Path)
}
```

**FSVolume.Operations — implement the shell methods:**

`func mount(options: FSTaskOptions, replyHandler: (FSItem, FSItem.Attributes, (any Error)?) -> Void)`:
- Create FSItem.Attributes for root:
  - type = .directory
  - mode = 0o755
  - uid = getuid(), gid = getgid()
  - size = 0
  - linkCount = 2
  - Set birthTime and modifyTime to current timespec (use `clock_gettime(CLOCK_REALTIME, &now)`)
- Reply with (rootItem, attrs, nil)
- Log mount

`func unmount(replyHandler: ((any Error)?) -> Void)`:
- `Task { await stagingManager.cleanupAll() }`
- Reply nil
- Log unmount

`func activate(options: FSTaskOptions, replyHandler: ((any Error)?) -> Void)`:
- Reply nil (no-op)

`func deactivate(options: FSDeactivateOptions, replyHandler: ((any Error)?) -> Void)`:
- Reply nil (no-op)

**Volume statistics:**
```swift
var volumeStatistics: FSStatFSResult {
    let result = FSStatFSResult()
    result.blockSize = 4096
    // Report 10 TB capacity (B2 has no fixed limit)
    let totalBlocks = UInt64(10 * 1024 * 1024 * 1024) * 1024 / 4096
    result.totalBlocks = totalBlocks
    result.availableBlocks = totalBlocks
    result.freeBlocks = totalBlocks
    result.usedBlocks = 0
    result.totalFiles = UInt64.max
    result.freeFiles = UInt64.max - 1
    return result
}

var supportedVolumeCapabilities: FSVolume.SupportedCapabilities {
    return FSVolume.SupportedCapabilities()
}

var isOpenCloseInhibited: Bool { false }
```

**PathConfOperations:**
```swift
var maxLinkCount: Int { 1 }
var maxNameLength: Int { 1024 }
var chownRestricted: Bool { true }
var truncateSupported: Bool { false }
```

**Stub the Operations methods that Plan 03 will implement** (so the class compiles):
- `lookupItem` — reply with `fs_errorForPOSIXError(ENOENT)` as placeholder
- `enumerateDirectory` — reply with verifier and nil error as placeholder
- `createItem` — reply with error ENOSYS as placeholder
- `removeItem` — reply with nil as placeholder
- `renameItem` — reply with error ENOSYS as placeholder
- `setAttributes` — reply with empty attributes as placeholder
- `getAttributes` — reply with empty attributes and nil error as placeholder
- `reclaimItem` — reply nil as placeholder

**Stub the ReadWrite + OpenClose methods that Plan 04 will implement:**
- `read` — reply with 0 bytes read as placeholder
- `write` — reply with 0 bytes written as placeholder
- `openItem` — reply nil as placeholder
- `closeItem` — reply nil as placeholder

Each stub should have a `// TODO: Plan 03/04 implementation` comment.

**Why stubs:** FSKit protocol conformance requires ALL methods present. Plans 03 and 04 will replace these stubs with real implementations.
  </action>
  <verify>Build with `xcodebuild -scheme CloudMount build CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO 2>&1 | tail -10` — full project should compile with the volume stubs</verify>
  <done>B2Volume compiles as FSVolume subclass with all required protocol conformances; mount returns root item; stubs exist for all operations to be implemented in Plans 03-04</done>
</task>

</tasks>

<verification>
- `CloudMountExtension.swift` has `@main` attribute and creates `CloudMountFileSystem()`
- `CloudMountFileSystem.swift` implements probe/load/unload lifecycle
- `B2Volume.swift` conforms to Operations, PathConfOperations, OpenCloseOperations, ReadWriteOperations
- Info.plist has FSSupportedSchemes with "b2"
- Full project builds: `xcodebuild -scheme CloudMount build CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO`
</verification>

<success_criteria>
Extension skeleton is complete: entry point loads, filesystem handles b2:// resources, volume mounts with root item and statistics. All protocol methods are stubbed so the project compiles, ready for Plans 03 and 04 to implement real operations.
</success_criteria>

<output>
After completion, create `.planning/phases/06-fskit-filesystem/06-02-SUMMARY.md`
</output>
