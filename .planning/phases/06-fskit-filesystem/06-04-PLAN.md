---
phase: 06-fskit-filesystem
plan: 04
type: execute
wave: 4
depends_on: ["06-03"]
files_modified:
  - CloudMountExtension/B2VolumeReadWrite.swift
  - CloudMountExtension/B2Volume.swift
autonomous: true

must_haves:
  truths:
    - "openItem downloads file content from B2 to local staging cache on first open"
    - "openItem serves from local cache when cached version matches remote (same fileId)"
    - "read returns data from the local cached/staging file at the requested offset"
    - "write stores data to the local staging file at the requested offset and marks item dirty"
    - "closeItem uploads dirty files to B2 when all open modes are released"
    - "Upload failure on close returns I/O error and keeps staged file for retry"
    - "Project builds successfully with all extension files"
  artifacts:
    - path: "CloudMountExtension/B2VolumeReadWrite.swift"
      provides: "Extension on B2Volume implementing ReadWriteOperations and OpenCloseOperations"
      contains: "func openItem"
  key_links:
    - from: "CloudMountExtension/B2VolumeReadWrite.swift"
      to: "CloudMountKit/B2/B2Client.swift"
      via: "downloadFile on open, uploadFile on close"
      pattern: "b2Client\\.downloadFile|b2Client\\.uploadFile"
    - from: "CloudMountExtension/B2VolumeReadWrite.swift"
      to: "CloudMountExtension/StagingManager.swift"
      via: "creates staging files, reads/writes through staging"
      pattern: "stagingManager\\."
    - from: "CloudMountExtension/B2VolumeReadWrite.swift"
      to: "CloudMountExtension/B2Item.swift"
      via: "reads localStagingURL, sets isDirty flag"
      pattern: "b2Item\\.isDirty|b2Item\\.localStagingURL"
---

<objective>
Implement the file I/O operations on B2Volume: open (download from B2), read (from local cache), write (to local staging), and close (upload dirty files to B2). This completes the filesystem — after this plan, users can read and write files on the mounted volume.

Purpose: This is the core file I/O that makes the mounted volume actually useful. Without open/read/write/close, users can only browse directories but can't access file contents.

Output: B2VolumeReadWrite.swift with real implementations replacing the stubs from Plan 02. Full project builds.
</objective>

<execution_context>
@~/.config/Claude/get-shit-done/workflows/execute-plan.md
@~/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-fskit-filesystem/06-RESEARCH.md
@.planning/phases/06-fskit-filesystem/06-CONTEXT.md
@.planning/phases/06-fskit-filesystem/06-03-SUMMARY.md
@CloudMountExtension/B2Volume.swift
@CloudMountExtension/B2Item.swift
@CloudMountExtension/StagingManager.swift
@CloudMountKit/B2/B2Client.swift
@CloudMountKit/Cache/FileCache.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: OpenClose and ReadWrite operations</name>
  <files>CloudMountExtension/B2VolumeReadWrite.swift, CloudMountExtension/B2Volume.swift</files>
  <action>
**Create** `CloudMountExtension/B2VolumeReadWrite.swift` — extension on B2Volume implementing `FSVolume.OpenCloseOperations` and `FSVolume.ReadWriteOperations`.

```swift
import FSKit
import CloudMountKit
import os
```

**openItem:**
```swift
func openItem(_ item: FSItem, modes: FSVolume.OpenModes,
              replyHandler: ((any Error)?) -> Void) {
    guard let b2Item = item as? B2Item else {
        replyHandler(fs_errorForPOSIXError(EINVAL))
        return
    }
    
    // Directories don't need download
    if b2Item.isDirectory {
        replyHandler(nil)
        return
    }
    
    // Suppressed items: no-op
    if MetadataBlocklist.isSuppressedPath(b2Item.b2Path) {
        replyHandler(nil)
        return
    }
    
    // If already have a staging file (e.g., newly created + not yet closed), reuse it
    Task {
        if await self.stagingManager.hasStagingFile(for: b2Item.b2Path) {
            replyHandler(nil)
            return
        }
        
        do {
            // Download file content from B2
            let data = try await self.b2Client.downloadFile(
                bucketName: self.bucketName,
                fileName: b2Item.b2Path
            )
            
            // Stage locally for read access
            let stagingURL = try await self.stagingManager.createStagingFile(
                for: b2Item.b2Path,
                initialData: data
            )
            b2Item.localStagingURL = stagingURL
            b2Item.contentLength = Int64(data.count)
            // Not dirty — just cached from remote
            
            replyHandler(nil)
        } catch {
            self.logger.error("openItem download failed for \(b2Item.b2Path): \(error)")
            replyHandler(fs_errorForPOSIXError(EIO))
        }
    }
}
```

**closeItem:**
```swift
func closeItem(_ item: FSItem, modes: FSVolume.OpenModes,
               replyHandler: ((any Error)?) -> Void) {
    guard let b2Item = item as? B2Item else {
        replyHandler(fs_errorForPOSIXError(EINVAL))
        return
    }
    
    // modes indicates which modes are being RETAINED (kept open)
    // When modes is empty, file is fully closed — time to upload if dirty
    guard modes.isEmpty else {
        // Still has open references — don't upload yet
        replyHandler(nil)
        return
    }
    
    // If not dirty, nothing to upload — just clean up
    guard b2Item.isDirty else {
        // Optionally clean up staging file for read-only opens
        // Keep it cached for future opens (performance)
        replyHandler(nil)
        return
    }
    
    // Suppressed items: just clear dirty flag, no upload
    if MetadataBlocklist.isSuppressedPath(b2Item.b2Path) {
        b2Item.isDirty = false
        replyHandler(nil)
        return
    }
    
    Task {
        do {
            // Read the staged file content
            guard await self.stagingManager.hasStagingFile(for: b2Item.b2Path) else {
                self.logger.warning("closeItem: dirty item has no staging file: \(b2Item.b2Path)")
                replyHandler(fs_errorForPOSIXError(EIO))
                return
            }
            
            // Read full staged content for upload
            // Get file size first
            let stagingURL = await self.stagingManager.stagingURL(for: b2Item.b2Path)
            let fileData = try Data(contentsOf: stagingURL)
            
            // Upload to B2
            let response = try await self.b2Client.uploadFile(
                bucketId: self.bucketId,
                bucketName: self.bucketName,
                fileName: b2Item.b2Path,
                data: fileData
            )
            
            // Update item metadata from upload response
            b2Item.b2FileId = response.fileId
            b2Item.contentLength = Int64(fileData.count)
            b2Item.isDirty = false
            b2Item.modificationTime = Date(timeIntervalSince1970: Double(response.uploadTimestamp.value) / 1000.0)
            
            self.logger.info("Uploaded \(b2Item.b2Path) (\(fileData.count) bytes)")
            replyHandler(nil)
        } catch {
            // Upload failed — keep staged file for retry, report error
            self.logger.error("closeItem upload failed for \(b2Item.b2Path): \(error)")
            // Keep isDirty = true and staging file intact
            replyHandler(fs_errorForPOSIXError(EIO))
        }
    }
}
```

**read:**
```swift
func read(from item: FSItem, at offset: off_t, length: Int,
          into buffer: FSMutableFileDataBuffer,
          replyHandler: (Int, (any Error)?) -> Void) {
    guard let b2Item = item as? B2Item else {
        replyHandler(0, fs_errorForPOSIXError(EINVAL))
        return
    }
    
    Task {
        do {
            let data = try await self.stagingManager.readFrom(
                b2Path: b2Item.b2Path,
                offset: Int64(offset),
                length: length
            )
            // Copy data into the FSKit buffer
            data.withUnsafeBytes { rawBuffer in
                if let baseAddress = rawBuffer.baseAddress {
                    buffer.copyBytes(from: baseAddress, count: data.count)
                }
            }
            replyHandler(data.count, nil)
        } catch {
            self.logger.error("read failed for \(b2Item.b2Path): \(error)")
            replyHandler(0, fs_errorForPOSIXError(EIO))
        }
    }
}
```

Note: The exact `FSMutableFileDataBuffer` API might differ. If `copyBytes(from:count:)` doesn't exist, check the FSKit header for the actual method. It might be `mutableBytes` or a different pattern. Adapt based on what Xcode shows. The key idea: copy the read data into the buffer provided by FSKit.

**write:**
```swift
func write(contents data: Data, to item: FSItem, at offset: off_t,
           replyHandler: (Int, (any Error)?) -> Void) {
    guard let b2Item = item as? B2Item else {
        replyHandler(0, fs_errorForPOSIXError(EINVAL))
        return
    }
    
    // Suppressed items: pretend to write
    if MetadataBlocklist.isSuppressedPath(b2Item.b2Path) {
        replyHandler(data.count, nil)
        return
    }
    
    Task {
        do {
            try await self.stagingManager.writeTo(
                b2Path: b2Item.b2Path,
                data: data,
                offset: Int64(offset)
            )
            b2Item.isDirty = true
            // Update content length if write extends the file
            let newEnd = Int64(offset) + Int64(data.count)
            if newEnd > b2Item.contentLength {
                b2Item.contentLength = newEnd
            }
            replyHandler(data.count, nil)
        } catch {
            self.logger.error("write failed for \(b2Item.b2Path): \(error)")
            replyHandler(0, fs_errorForPOSIXError(EIO))
        }
    }
}
```

**Update B2Volume.swift:** Remove the ReadWrite and OpenClose stub methods (openItem, closeItem, read, write) since they now live in B2VolumeReadWrite.swift. After this, B2Volume.swift should only contain:
- Class declaration with properties, init, and helper methods
- mount/unmount/activate/deactivate
- volumeStatistics, supportedVolumeCapabilities, isOpenCloseInhibited
- PathConfOperations properties
- allocateItemId, cachedItem, cacheItem, removeCachedItem helpers

All protocol methods are now spread across:
- B2Volume.swift: mount, unmount, activate, deactivate, PathConf, volume metadata
- B2VolumeOperations.swift: lookup, enumerate, create, remove, rename, attributes, reclaim
- B2VolumeReadWrite.swift: open, close, read, write
  </action>
  <verify>Build with `xcodebuild -scheme CloudMount build CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO 2>&1 | tail -20` — full project must compile with zero errors. All FSVolume protocol requirements are satisfied.</verify>
  <done>File I/O operations complete: openItem downloads from B2, read serves from local cache, write goes to staging, closeItem uploads dirty files to B2. Upload failures preserve staged files. Full project builds successfully.</done>
</task>

<task type="auto">
  <name>Task 2: Build verification and final cleanup</name>
  <files></files>
  <action>
Run a clean build of the entire project to verify everything compiles together:

```bash
xcodebuild -scheme CloudMount clean build CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO 2>&1
```

If there are compilation errors:
1. Fix any type mismatches between FSKit API expectations and our implementation (FSKit is new, some method signatures may differ from the research doc)
2. Fix any Swift 6 concurrency issues (Sendable warnings, actor isolation)
3. Fix any import issues (missing `import FSKit` or `import CloudMountKit`)
4. Ensure all FSVolume protocol requirements are satisfied (no missing methods)

Common issues to check:
- `FSFileName` constructor: might be `FSFileName(string:)` or `FSFileName(_ string:)` — match the actual API
- `FSDirectoryCookie`: might be a struct with specific initializer or just a typealias for UInt64
- `FSMutableFileDataBuffer`: verify the copy method signature
- `FSItem.Identifier`: verify `.number(UInt64)` is correct
- `FSProbeResult`: verify constructor signature
- `FSStatFSResult`: verify property names match
- `fs_errorForPOSIXError`: verify it exists and takes the right parameter type
- `FSVolume.OpenModes`: verify `.isEmpty` works for checking "all closed"
- `FSVolume.Identifier`: verify constructor (might take UUID or other format)
- `FSItem.Attributes` setters: verify property names (e.g., `type`, `mode`, `uid`, `gid`, `size`, `linkCount`, `modifyTime`, `birthTime`)

Fix any issues found. The goal is a green build.

Also verify the file structure matches expectations:
```
CloudMountExtension/
├── CloudMountExtension.swift          # @main entry point
├── CloudMountFileSystem.swift         # FSUnaryFileSystem lifecycle
├── B2Volume.swift                     # FSVolume base + mount/pathconf
├── B2VolumeOperations.swift           # lookup, enumerate, create, remove, rename, attrs
├── B2VolumeReadWrite.swift            # open, close, read, write
├── B2Item.swift                       # FSItem subclass
├── B2ItemAttributes.swift             # Attribute mapping helpers
├── MetadataBlocklist.swift            # macOS metadata suppression
├── StagingManager.swift               # Write staging temp files
├── Info.plist                         # Extension config with FSSupportedSchemes
└── CloudMountExtension.entitlements   # Keychain + App Group
```
  </action>
  <verify>Clean build succeeds: `xcodebuild -scheme CloudMount clean build CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO 2>&1 | grep -E "BUILD (SUCCEEDED|FAILED)"` outputs `BUILD SUCCEEDED`. Count extension Swift files: `ls CloudMountExtension/*.swift | wc -l` outputs 9.</verify>
  <done>Full project compiles with all 9 extension Swift files, no errors. All FSVolume protocol methods implemented. Extension is structurally complete and ready for runtime testing in Phase 7.</done>
</task>

</tasks>

<verification>
- openItem downloads from B2 and stages locally; serves from cache on subsequent opens
- closeItem uploads dirty files to B2; keeps staged file on failure
- read returns data from staging file at requested offset
- write stores data to staging file and marks item dirty
- Full clean build succeeds with all extension files
- File structure has 9 Swift files in CloudMountExtension/
</verification>

<success_criteria>
FSKit filesystem extension is structurally complete: all volume operations (browse, read, write, delete, rename) are implemented and wired to B2Client. The project builds cleanly. Extension is ready for integration testing when mounted via the host app (Phase 7).
</success_criteria>

<output>
After completion, create `.planning/phases/06-fskit-filesystem/06-04-SUMMARY.md`
</output>
