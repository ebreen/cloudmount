---
phase: 06-fskit-filesystem
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - CloudMountExtension/B2VolumeOperations.swift
  - CloudMountExtension/B2ItemAttributes.swift
  - CloudMountExtension/B2Volume.swift
autonomous: true

must_haves:
  truths:
    - "lookupItem resolves a file/directory name within a parent directory by querying B2 metadata cache"
    - "enumerateDirectory lists directory contents from B2 and packs entries via FSDirectoryEntryPacker"
    - "createItem creates files (local placeholder) and directories (B2 marker upload) with metadata suppression"
    - "removeItem deletes files from B2 and cleans up cached items"
    - "Files and directories can be renamed and moved between directories (directories without b2FileId return ENOTSUP)"
    - "getAttributes returns B2 metadata mapped to FSItem.Attributes"
    - "Suppressed metadata paths (DS_Store, ._ files) return success without B2 API calls"
  artifacts:
    - path: "CloudMountExtension/B2VolumeOperations.swift"
      provides: "Extension on B2Volume implementing all FSVolume.Operations methods"
      contains: "func lookupItem"
    - path: "CloudMountExtension/B2ItemAttributes.swift"
      provides: "Helper to map B2FileInfo and B2Item properties to FSItem.Attributes"
      contains: "func makeAttributes"
  key_links:
    - from: "CloudMountExtension/B2VolumeOperations.swift"
      to: "CloudMountKit/B2/B2Client.swift"
      via: "calls listDirectory, deleteFile, copyFile, createFolder"
      pattern: "b2Client\\."
    - from: "CloudMountExtension/B2VolumeOperations.swift"
      to: "CloudMountExtension/MetadataBlocklist.swift"
      via: "checks suppression before B2 API calls"
      pattern: "MetadataBlocklist.isSuppressed"
    - from: "CloudMountExtension/B2VolumeOperations.swift"
      to: "CloudMountExtension/B2Item.swift"
      via: "creates and caches B2Item instances for every lookup/create"
      pattern: "B2Item("
---

<objective>
Implement the core FSVolume.Operations methods on B2Volume: lookup, enumerate directory, create item, remove item, rename item, get/set attributes, and reclaim. These replace the stubs from Plan 02 with real B2-backed implementations.

Purpose: These operations are what Finder calls when users browse directories, create files/folders, delete items, and rename things. Without these, the mounted volume is an empty shell.

Output: B2VolumeOperations.swift (extension on B2Volume with all Operations methods), B2ItemAttributes.swift (attribute mapping helper), updated B2Volume.swift (remove stubs for Operations methods).
</objective>

<execution_context>
@~/.config/Claude/get-shit-done/workflows/execute-plan.md
@~/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-fskit-filesystem/06-RESEARCH.md
@.planning/phases/06-fskit-filesystem/06-CONTEXT.md
@.planning/phases/06-fskit-filesystem/06-02-SUMMARY.md
@CloudMountExtension/B2Volume.swift
@CloudMountExtension/B2Item.swift
@CloudMountExtension/MetadataBlocklist.swift
@CloudMountKit/B2/B2Client.swift
@CloudMountKit/B2/B2Types.swift
@CloudMountKit/Cache/MetadataCache.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: B2ItemAttributes helper + read-only operations (lookup, enumerate, getAttributes, setAttributes, reclaim)</name>
  <files>CloudMountExtension/B2ItemAttributes.swift, CloudMountExtension/B2VolumeOperations.swift, CloudMountExtension/B2Volume.swift</files>
  <action>
**Create** `CloudMountExtension/B2ItemAttributes.swift` — helper for creating FSItem.Attributes from B2 data:

```swift
import FSKit
import CloudMountKit
```

Extension on B2Volume (or a free function/helper struct) with:

```swift
func makeAttributes(for item: B2Item) -> FSItem.Attributes {
    let attrs = FSItem.Attributes()
    if item.isDirectory {
        attrs.type = .directory
        attrs.mode = 0o755
        attrs.linkCount = 2
        attrs.size = 0
    } else {
        attrs.type = .regular
        attrs.mode = 0o644
        attrs.linkCount = 1
        attrs.size = UInt64(item.contentLength)
    }
    attrs.uid = getuid()
    attrs.gid = getgid()
    
    // Convert Date to timespec
    let modTime = item.modificationTime
    let seconds = Int(modTime.timeIntervalSince1970)
    let nanos = Int((modTime.timeIntervalSince1970 - Double(seconds)) * 1_000_000_000)
    var ts = timespec(tv_sec: seconds, tv_nsec: nanos)
    attrs.modifyTime = ts
    attrs.birthTime = ts  // B2 doesn't track creation separately
    attrs.accessTime = ts
    attrs.changeTime = ts
    
    return attrs
}
```

Also add `extractFileName` helper to B2ItemAttributes.swift (used by both lookup and enumerate):

```swift
func extractFileName(from b2FileName: String, parentPath: String) -> String {
    var name = b2FileName
    if name.hasPrefix(parentPath) {
        name = String(name.dropFirst(parentPath.count))
    }
    if name.hasSuffix("/") {
        name = String(name.dropLast())
    }
    return name
}
```

**Create** `CloudMountExtension/B2VolumeOperations.swift` — extension on B2Volume implementing FSVolume.Operations methods. This task implements the read-only operations only.

**Remove** the Operations stub methods from `B2Volume.swift` (lookup, enumerate, create, remove, rename, setAttributes, getAttributes, reclaim) — they move to the new file. Keep the ReadWrite/OpenClose stubs in B2Volume.swift (Plan 04 handles those).

Each method uses `Task {}` to bridge to async B2Client calls. Each calls `replyHandler` exactly once.

**lookupItem:**
```swift
func lookupItem(named name: FSFileName, inDirectory directory: FSItem,
                replyHandler: (FSItem?, FSItem.Attributes?, (any Error)?) -> Void) {
    guard let parentItem = directory as? B2Item else {
        replyHandler(nil, nil, fs_errorForPOSIXError(EINVAL))
        return
    }
    
    let nameStr = name.string
    
    // Check metadata suppression
    if MetadataBlocklist.isSuppressed(nameStr) {
        replyHandler(nil, nil, fs_errorForPOSIXError(ENOENT))
        return
    }
    
    // Build full B2 path
    let b2Path = parentItem.b2Path.isEmpty ? nameStr : parentItem.b2Path + "/" + nameStr
    
    // Check item cache first
    if let cached = cachedItem(for: b2Path) {
        replyHandler(cached, makeAttributes(for: cached), nil)
        return
    }
    // Also check for directory version (with trailing /)
    if let cached = cachedItem(for: b2Path + "/") {
        replyHandler(cached, makeAttributes(for: cached), nil)
        return
    }
    
    Task {
        do {
            let parentPath = parentItem.b2Path.isEmpty ? "" : parentItem.b2Path + "/"
            let entries = try await self.b2Client.listDirectory(bucketId: self.bucketId, path: parentPath)
            
            for entry in entries {
                let entryName = self.extractFileName(from: entry.fileName, parentPath: parentPath)
                if entryName == nameStr {
                    let item = B2Item.fromB2FileInfo(entry, identifier: self.allocateItemId())
                    self.cacheItem(item)
                    replyHandler(item, self.makeAttributes(for: item), nil)
                    return
                }
            }
            
            replyHandler(nil, nil, fs_errorForPOSIXError(ENOENT))
        } catch {
            self.logger.error("lookupItem failed: \(error)")
            replyHandler(nil, nil, fs_errorForPOSIXError(EIO))
        }
    }
}
```

**enumerateDirectory:**
```swift
func enumerateDirectory(_ directory: FSItem, startingAt cookie: FSDirectoryCookie,
                        verifier: FSDirectoryVerifier, attributes: FSItem.GetAttributesRequest,
                        packer: FSDirectoryEntryPacker,
                        replyHandler: (FSDirectoryVerifier, (any Error)?) -> Void) {
    guard let parentItem = directory as? B2Item else {
        replyHandler(verifier, fs_errorForPOSIXError(EINVAL))
        return
    }
    
    Task {
        do {
            let parentPath = parentItem.b2Path.isEmpty ? "" : parentItem.b2Path + "/"
            let entries = try await self.b2Client.listDirectory(bucketId: self.bucketId, path: parentPath)
            
            let startIndex = Int(cookie.rawValue)
            let filteredEntries = entries.filter { entry in
                let name = self.extractFileName(from: entry.fileName, parentPath: parentPath)
                return !MetadataBlocklist.isSuppressed(name) && !name.isEmpty
            }
            
            for (index, entry) in filteredEntries.enumerated() {
                guard index >= startIndex else { continue }
                
                let name = self.extractFileName(from: entry.fileName, parentPath: parentPath)
                let item = B2Item.fromB2FileInfo(entry, identifier: self.allocateItemId())
                self.cacheItem(item)
                
                let entryAttrs = self.makeAttributes(for: item)
                let nextCookie = FSDirectoryCookie(rawValue: UInt64(index + 1))
                
                if !packer.packEntry(name: FSFileName(string: name),
                                     itemID: item.identifier,
                                     cookie: nextCookie,
                                     attributes: entryAttrs) {
                    break
                }
            }
            
            replyHandler(verifier, nil)
        } catch {
            self.logger.error("enumerateDirectory failed: \(error)")
            replyHandler(verifier, fs_errorForPOSIXError(EIO))
        }
    }
}
```

Note: The exact `FSDirectoryCookie` and `packer.packEntry` signatures may differ from the docs. If `FSDirectoryCookie` doesn't have `rawValue` or the packer signature differs, adapt based on Xcode's autocomplete/headers. The cookie might just be a UInt64 or have a different constructor. The packer's `packEntry` method signature needs to match the actual FSKit API — check the FSKit header at build time and adapt. The general pattern is correct.

**getAttributes:**
```swift
func getAttributes(_ attributes: FSItem.GetAttributesRequest, of item: FSItem,
                   replyHandler: (FSItem.Attributes?, (any Error)?) -> Void) {
    guard let b2Item = item as? B2Item else {
        replyHandler(nil, fs_errorForPOSIXError(EINVAL))
        return
    }
    replyHandler(makeAttributes(for: b2Item), nil)
}
```

**setAttributes:**
```swift
func setAttributes(_ newAttributes: FSItem.Attributes, on item: FSItem,
                   replyHandler: (FSItem.Attributes?, (any Error)?) -> Void) {
    // B2 doesn't support setting attributes (no chmod, chown, utimes)
    // Return current attributes unchanged
    guard let b2Item = item as? B2Item else {
        replyHandler(nil, fs_errorForPOSIXError(EINVAL))
        return
    }
    replyHandler(makeAttributes(for: b2Item), nil)
}
```

**reclaimItem:**
```swift
func reclaimItem(_ item: FSItem, replyHandler: ((any Error)?) -> Void) {
    if let b2Item = item as? B2Item {
        removeCachedItem(for: b2Item.b2Path)
    }
    replyHandler(nil)
}
```
  </action>
  <verify>Build with `xcodebuild -scheme CloudMount build CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO 2>&1 | tail -10` — project compiles. Verify B2VolumeOperations.swift contains lookupItem, enumerateDirectory, getAttributes, setAttributes, reclaimItem methods: `grep -c 'func \(lookupItem\|enumerateDirectory\|getAttributes\|setAttributes\|reclaimItem\)' CloudMountExtension/B2VolumeOperations.swift` outputs 5.</verify>
  <done>Attribute helper maps B2Item to FSItem.Attributes with correct type/mode/timestamps. lookupItem resolves names via B2 directory listing with cache and suppression. enumerateDirectory packs entries via FSDirectoryEntryPacker. getAttributes/setAttributes/reclaimItem handle metadata. Suppressed paths return ENOENT on lookup without B2 API calls.</done>
</task>

<task type="auto">
  <name>Task 2: Mutation operations (createItem, removeItem, renameItem)</name>
  <files>CloudMountExtension/B2VolumeOperations.swift</files>
  <action>
Add the mutation operations to the existing `B2VolumeOperations.swift` extension (or a second extension in the same file).

**createItem:**
```swift
func createItem(named name: FSFileName, type: FSItem.ItemType, inDirectory directory: FSItem,
                attributes: FSItem.Attributes,
                replyHandler: (FSItem?, FSItem.Attributes?, (any Error)?) -> Void) {
    guard let parentItem = directory as? B2Item else {
        replyHandler(nil, nil, fs_errorForPOSIXError(EINVAL))
        return
    }
    
    let nameStr = name.string
    
    // Suppress macOS metadata
    if MetadataBlocklist.isSuppressed(nameStr) {
        let fakePath = parentItem.b2Path.isEmpty ? nameStr : parentItem.b2Path + "/" + nameStr
        let fakeItem = B2Item(
            name: name,
            identifier: allocateItemId(),
            b2Path: fakePath,
            bucketId: bucketId,
            isDirectory: type == .directory
        )
        replyHandler(fakeItem, makeAttributes(for: fakeItem), nil)
        return
    }
    
    let b2Path = parentItem.b2Path.isEmpty ? nameStr : parentItem.b2Path + "/" + nameStr
    
    Task {
        do {
            if type == .directory {
                try await self.b2Client.createFolder(
                    bucketId: self.bucketId,
                    bucketName: self.bucketName,
                    folderPath: b2Path
                )
                let item = B2Item(
                    name: name,
                    identifier: self.allocateItemId(),
                    b2Path: b2Path + "/",
                    bucketId: self.bucketId,
                    isDirectory: true
                )
                self.cacheItem(item)
                replyHandler(item, self.makeAttributes(for: item), nil)
            } else {
                let item = B2Item(
                    name: name,
                    identifier: self.allocateItemId(),
                    b2Path: b2Path,
                    bucketId: self.bucketId,
                    isDirectory: false
                )
                let stagingURL = try await self.stagingManager.createStagingFile(for: b2Path, initialData: Data())
                item.localStagingURL = stagingURL
                item.isDirty = true
                self.cacheItem(item)
                replyHandler(item, self.makeAttributes(for: item), nil)
            }
        } catch {
            self.logger.error("createItem failed: \(error)")
            replyHandler(nil, nil, fs_errorForPOSIXError(EIO))
        }
    }
}
```

**removeItem:**
```swift
func removeItem(_ item: FSItem, named name: FSFileName, fromDirectory directory: FSItem,
                replyHandler: ((any Error)?) -> Void) {
    guard let b2Item = item as? B2Item else {
        replyHandler(fs_errorForPOSIXError(EINVAL))
        return
    }
    
    if MetadataBlocklist.isSuppressed(name.string) {
        removeCachedItem(for: b2Item.b2Path)
        replyHandler(nil)
        return
    }
    
    Task {
        do {
            if let fileId = b2Item.b2FileId {
                try await self.b2Client.deleteFile(
                    bucketId: self.bucketId,
                    fileName: b2Item.b2Path,
                    fileId: fileId
                )
            }
            await self.stagingManager.removeStagingFile(for: b2Item.b2Path)
            self.removeCachedItem(for: b2Item.b2Path)
            replyHandler(nil)
        } catch {
            self.logger.error("removeItem failed: \(error)")
            replyHandler(fs_errorForPOSIXError(EIO))
        }
    }
}
```

**renameItem:**

**Important limitation:** B2 has no native rename — it requires server-side copy + delete, which only works for files that have a `b2FileId`. Directories in B2 are either folder markers (with fileId) or inferred from child paths (no fileId). Renaming a non-empty directory would require recursively renaming all children, which is expensive and error-prone. Therefore:
- **Files:** Rename via server-side copy + delete (requires b2FileId).
- **Directories:** Return `ENOTSUP`. Finder will fall back to copy + delete at the file level. This is the safe approach for v1 — recursive directory rename can be added later if needed.

```swift
func renameItem(_ item: FSItem, inDirectory sourceDirectory: FSItem, named sourceName: FSFileName,
                toDirectory destDirectory: FSItem, newName: FSFileName, overItem: FSItem?,
                replyHandler: ((any Error)?) -> Void) {
    guard let b2Item = item as? B2Item,
          let destParent = destDirectory as? B2Item else {
        replyHandler(fs_errorForPOSIXError(EINVAL))
        return
    }
    
    // Directories: return ENOTSUP — B2 has no native rename and recursive
    // child renames for non-empty directories are expensive/error-prone.
    // Finder will fall back to copy + delete at the file level.
    if b2Item.isDirectory {
        replyHandler(fs_errorForPOSIXError(ENOTSUP))
        return
    }
    
    let newNameStr = newName.string
    let destPath = destParent.b2Path.isEmpty ? newNameStr : destParent.b2Path + "/" + newNameStr
    
    Task {
        do {
            guard let fileId = b2Item.b2FileId else {
                // File without b2FileId (e.g., newly created, not yet uploaded)
                // Just update local state
                self.removeCachedItem(for: b2Item.b2Path)
                b2Item.b2Path = destPath
                b2Item.name = newName
                self.cacheItem(b2Item)
                replyHandler(nil)
                return
            }
            
            try await self.b2Client.rename(
                bucketId: self.bucketId,
                sourceFileName: b2Item.b2Path,
                sourceFileId: fileId,
                destinationFileName: destPath
            )
            
            self.removeCachedItem(for: b2Item.b2Path)
            b2Item.b2Path = destPath  // Note: b2Path must be var in B2Item
            b2Item.name = newName
            self.cacheItem(b2Item)
            
            replyHandler(nil)
        } catch {
            self.logger.error("renameItem failed: \(error)")
            replyHandler(fs_errorForPOSIXError(EIO))
        }
    }
}
```

Note: For `b2Item.b2Path = destPath` to work, `b2Path` in B2Item must be declared as `var`, not `let`. If Plan 01 made it `let`, change it to `var` in this task.
  </action>
  <verify>Build with `xcodebuild -scheme CloudMount build CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO 2>&1 | tail -10` — project compiles. Verify mutation methods exist: `grep -c 'func \(createItem\|removeItem\|renameItem\)' CloudMountExtension/B2VolumeOperations.swift` outputs 3.</verify>
  <done>createItem creates files (local staging placeholder) and directories (B2 folder marker) with metadata suppression. removeItem deletes from B2 and cleans up cache/staging. renameItem handles file rename via server-side copy+delete; directories return ENOTSUP (documented limitation — Finder falls back to copy+delete).</done>
</task>

</tasks>

<verification>
- `lookupItem` finds items by listing parent directory on B2 and matching name
- `enumerateDirectory` lists B2 directory contents and packs into FSDirectoryEntryPacker
- `getAttributes` returns correct type, mode, size, timestamps from B2Item
- `createItem` for directories uploads B2 folder marker; for files creates local staging placeholder
- `removeItem` calls B2 delete API and cleans up local cache
- `renameItem` renames files via B2 copy + delete; returns ENOTSUP for directories
- Suppressed metadata paths (.DS_Store, ._ files) handled without B2 API calls
- Project builds successfully after both tasks
</verification>

<success_criteria>
Volume supports all directory operations: users can browse directories (lookup + enumerate), create files and folders (create), delete items (remove), and rename/move items (rename). Metadata suppression prevents B2 API calls for Finder noise.
</success_criteria>

<output>
After completion, create `.planning/phases/06-fskit-filesystem/06-03-SUMMARY.md`
</output>
