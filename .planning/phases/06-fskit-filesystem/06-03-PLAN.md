---
phase: 06-fskit-filesystem
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - CloudMountExtension/B2VolumeOperations.swift
  - CloudMountExtension/B2ItemAttributes.swift
  - CloudMountExtension/B2Volume.swift
autonomous: true

must_haves:
  truths:
    - "lookupItem resolves a file/directory name within a parent directory by querying B2 metadata cache"
    - "enumerateDirectory lists directory contents from B2 and packs entries via FSDirectoryEntryPacker"
    - "createItem creates files (local placeholder) and directories (B2 marker upload) with metadata suppression"
    - "removeItem deletes files from B2 and cleans up cached items"
    - "renameItem performs server-side copy + delete for renames/moves"
    - "getAttributes returns B2 metadata mapped to FSItem.Attributes"
    - "Suppressed metadata paths (DS_Store, ._ files) return success without B2 API calls"
  artifacts:
    - path: "CloudMountExtension/B2VolumeOperations.swift"
      provides: "Extension on B2Volume implementing all FSVolume.Operations methods"
      contains: "func lookupItem"
    - path: "CloudMountExtension/B2ItemAttributes.swift"
      provides: "Helper to map B2FileInfo and B2Item properties to FSItem.Attributes"
      contains: "func makeAttributes"
  key_links:
    - from: "CloudMountExtension/B2VolumeOperations.swift"
      to: "CloudMountKit/B2/B2Client.swift"
      via: "calls listDirectory, deleteFile, copyFile, createFolder"
      pattern: "b2Client\\."
    - from: "CloudMountExtension/B2VolumeOperations.swift"
      to: "CloudMountExtension/MetadataBlocklist.swift"
      via: "checks suppression before B2 API calls"
      pattern: "MetadataBlocklist.isSuppressed"
    - from: "CloudMountExtension/B2VolumeOperations.swift"
      to: "CloudMountExtension/B2Item.swift"
      via: "creates and caches B2Item instances for every lookup/create"
      pattern: "B2Item("
---

<objective>
Implement the core FSVolume.Operations methods on B2Volume: lookup, enumerate directory, create item, remove item, rename item, get/set attributes, and reclaim. These replace the stubs from Plan 02 with real B2-backed implementations.

Purpose: These operations are what Finder calls when users browse directories, create files/folders, delete items, and rename things. Without these, the mounted volume is an empty shell.

Output: B2VolumeOperations.swift (extension on B2Volume with all Operations methods), B2ItemAttributes.swift (attribute mapping helper), updated B2Volume.swift (remove stubs for Operations methods).
</objective>

<execution_context>
@~/.config/Claude/get-shit-done/workflows/execute-plan.md
@~/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-fskit-filesystem/06-RESEARCH.md
@.planning/phases/06-fskit-filesystem/06-CONTEXT.md
@.planning/phases/06-fskit-filesystem/06-02-SUMMARY.md
@CloudMountExtension/B2Volume.swift
@CloudMountExtension/B2Item.swift
@CloudMountExtension/MetadataBlocklist.swift
@CloudMountKit/B2/B2Client.swift
@CloudMountKit/B2/B2Types.swift
@CloudMountKit/Cache/MetadataCache.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: B2ItemAttributes helper and volume operations (lookup, enumerate, create, remove, rename, attributes, reclaim)</name>
  <files>CloudMountExtension/B2ItemAttributes.swift, CloudMountExtension/B2VolumeOperations.swift, CloudMountExtension/B2Volume.swift</files>
  <action>
**Create** `CloudMountExtension/B2ItemAttributes.swift` — helper for creating FSItem.Attributes from B2 data:

```swift
import FSKit
import CloudMountKit
```

Extension on B2Volume (or a free function/helper struct) with:

```swift
func makeAttributes(for item: B2Item) -> FSItem.Attributes {
    let attrs = FSItem.Attributes()
    if item.isDirectory {
        attrs.type = .directory
        attrs.mode = 0o755
        attrs.linkCount = 2
        attrs.size = 0
    } else {
        attrs.type = .regular
        attrs.mode = 0o644
        attrs.linkCount = 1
        attrs.size = UInt64(item.contentLength)
    }
    attrs.uid = getuid()
    attrs.gid = getgid()
    
    // Convert Date to timespec
    let modTime = item.modificationTime
    let seconds = Int(modTime.timeIntervalSince1970)
    let nanos = Int((modTime.timeIntervalSince1970 - Double(seconds)) * 1_000_000_000)
    var ts = timespec(tv_sec: seconds, tv_nsec: nanos)
    attrs.modifyTime = ts
    attrs.birthTime = ts  // B2 doesn't track creation separately
    attrs.accessTime = ts
    attrs.changeTime = ts
    
    return attrs
}
```

**Create** `CloudMountExtension/B2VolumeOperations.swift` — extension on B2Volume implementing all FSVolume.Operations methods.

**Remove** the Operations stub methods from `B2Volume.swift` (lookup, enumerate, create, remove, rename, setAttributes, getAttributes, reclaim) — they move to the new file. Keep the ReadWrite/OpenClose stubs in B2Volume.swift (Plan 04 handles those).

Each method uses `Task {}` to bridge to async B2Client calls. Each calls `replyHandler` exactly once.

**lookupItem:**
```swift
func lookupItem(named name: FSFileName, inDirectory directory: FSItem,
                replyHandler: (FSItem?, FSItem.Attributes?, (any Error)?) -> Void) {
    guard let parentItem = directory as? B2Item else {
        replyHandler(nil, nil, fs_errorForPOSIXError(EINVAL))
        return
    }
    
    let nameStr = name.string
    
    // Check metadata suppression
    if MetadataBlocklist.isSuppressed(nameStr) {
        replyHandler(nil, nil, fs_errorForPOSIXError(ENOENT))
        return
    }
    
    // Build full B2 path
    let b2Path = parentItem.b2Path.isEmpty ? nameStr : parentItem.b2Path + "/" + nameStr
    
    // Check item cache first
    if let cached = cachedItem(for: b2Path) {
        replyHandler(cached, makeAttributes(for: cached), nil)
        return
    }
    // Also check for directory version (with trailing /)
    if let cached = cachedItem(for: b2Path + "/") {
        replyHandler(cached, makeAttributes(for: cached), nil)
        return
    }
    
    Task {
        do {
            // List the parent directory to find the item
            let parentPath = parentItem.b2Path.isEmpty ? "" : parentItem.b2Path + "/"
            let entries = try await self.b2Client.listDirectory(bucketId: self.bucketId, path: parentPath)
            
            // Find matching entry
            for entry in entries {
                let entryName = self.extractFileName(from: entry.fileName, parentPath: parentPath)
                if entryName == nameStr {
                    let item = B2Item.fromB2FileInfo(entry, identifier: self.allocateItemId())
                    self.cacheItem(item)
                    replyHandler(item, self.makeAttributes(for: item), nil)
                    return
                }
            }
            
            // Not found
            replyHandler(nil, nil, fs_errorForPOSIXError(ENOENT))
        } catch {
            self.logger.error("lookupItem failed: \(error)")
            replyHandler(nil, nil, fs_errorForPOSIXError(EIO))
        }
    }
}
```

Helper method on B2Volume:
```swift
func extractFileName(from b2FileName: String, parentPath: String) -> String {
    // Remove parent prefix, then trailing /
    var name = b2FileName
    if name.hasPrefix(parentPath) {
        name = String(name.dropFirst(parentPath.count))
    }
    if name.hasSuffix("/") {
        name = String(name.dropLast())
    }
    return name
}
```

**enumerateDirectory:**
```swift
func enumerateDirectory(_ directory: FSItem, startingAt cookie: FSDirectoryCookie,
                        verifier: FSDirectoryVerifier, attributes: FSItem.GetAttributesRequest,
                        packer: FSDirectoryEntryPacker,
                        replyHandler: (FSDirectoryVerifier, (any Error)?) -> Void) {
    guard let parentItem = directory as? B2Item else {
        replyHandler(verifier, fs_errorForPOSIXError(EINVAL))
        return
    }
    
    Task {
        do {
            let parentPath = parentItem.b2Path.isEmpty ? "" : parentItem.b2Path + "/"
            let entries = try await self.b2Client.listDirectory(bucketId: self.bucketId, path: parentPath)
            
            // Filter suppressed entries and skip to cookie position
            let startIndex = Int(cookie.rawValue)  // cookie is 0-based index; 0 = start from beginning
            let filteredEntries = entries.filter { entry in
                let name = self.extractFileName(from: entry.fileName, parentPath: parentPath)
                return !MetadataBlocklist.isSuppressed(name) && !name.isEmpty
            }
            
            for (index, entry) in filteredEntries.enumerated() {
                guard index >= startIndex else { continue }
                
                let name = self.extractFileName(from: entry.fileName, parentPath: parentPath)
                let item = B2Item.fromB2FileInfo(entry, identifier: self.allocateItemId())
                self.cacheItem(item)
                
                let entryAttrs = self.makeAttributes(for: item)
                let nextCookie = FSDirectoryCookie(rawValue: UInt64(index + 1))
                
                // packEntry returns false when buffer is full
                if !packer.packEntry(name: FSFileName(string: name),
                                     itemID: item.identifier,
                                     cookie: nextCookie,
                                     attributes: entryAttrs) {
                    break
                }
            }
            
            replyHandler(verifier, nil)
        } catch {
            self.logger.error("enumerateDirectory failed: \(error)")
            replyHandler(verifier, fs_errorForPOSIXError(EIO))
        }
    }
}
```

Note: The exact `FSDirectoryCookie` and `packer.packEntry` signatures may differ from the docs. If `FSDirectoryCookie` doesn't have `rawValue` or the packer signature differs, adapt based on Xcode's autocomplete/headers. The cookie might just be a UInt64 or have a different constructor. The packer's `packEntry` method signature needs to match the actual FSKit API — check the FSKit header at build time and adapt. The general pattern is correct.

**createItem:**
```swift
func createItem(named name: FSFileName, type: FSItem.ItemType, inDirectory directory: FSItem,
                attributes: FSItem.Attributes,
                replyHandler: (FSItem?, FSItem.Attributes?, (any Error)?) -> Void) {
    guard let parentItem = directory as? B2Item else {
        replyHandler(nil, nil, fs_errorForPOSIXError(EINVAL))
        return
    }
    
    let nameStr = name.string
    
    // Suppress macOS metadata
    if MetadataBlocklist.isSuppressed(nameStr) {
        // Create a fake item and return success — no B2 API call
        let fakePath = parentItem.b2Path.isEmpty ? nameStr : parentItem.b2Path + "/" + nameStr
        let fakeItem = B2Item(
            name: name,
            identifier: allocateItemId(),
            b2Path: fakePath,
            bucketId: bucketId,
            isDirectory: type == .directory
        )
        replyHandler(fakeItem, makeAttributes(for: fakeItem), nil)
        return
    }
    
    let b2Path = parentItem.b2Path.isEmpty ? nameStr : parentItem.b2Path + "/" + nameStr
    
    Task {
        do {
            if type == .directory {
                // Create directory marker on B2
                try await self.b2Client.createFolder(
                    bucketId: self.bucketId,
                    bucketName: self.bucketName,
                    folderPath: b2Path
                )
                let item = B2Item(
                    name: name,
                    identifier: self.allocateItemId(),
                    b2Path: b2Path + "/",
                    bucketId: self.bucketId,
                    isDirectory: true
                )
                self.cacheItem(item)
                replyHandler(item, self.makeAttributes(for: item), nil)
            } else {
                // Create local placeholder — actual upload happens on close
                let item = B2Item(
                    name: name,
                    identifier: self.allocateItemId(),
                    b2Path: b2Path,
                    bucketId: self.bucketId,
                    isDirectory: false
                )
                // Create empty staging file
                let stagingURL = try await self.stagingManager.createStagingFile(for: b2Path, initialData: Data())
                item.localStagingURL = stagingURL
                item.isDirty = true
                self.cacheItem(item)
                replyHandler(item, self.makeAttributes(for: item), nil)
            }
        } catch {
            self.logger.error("createItem failed: \(error)")
            replyHandler(nil, nil, fs_errorForPOSIXError(EIO))
        }
    }
}
```

**removeItem:**
```swift
func removeItem(_ item: FSItem, named name: FSFileName, fromDirectory directory: FSItem,
                replyHandler: ((any Error)?) -> Void) {
    guard let b2Item = item as? B2Item else {
        replyHandler(fs_errorForPOSIXError(EINVAL))
        return
    }
    
    // Suppressed items: just remove from cache silently
    if MetadataBlocklist.isSuppressed(name.string) {
        removeCachedItem(for: b2Item.b2Path)
        replyHandler(nil)
        return
    }
    
    Task {
        do {
            if let fileId = b2Item.b2FileId {
                try await self.b2Client.deleteFile(
                    bucketId: self.bucketId,
                    fileName: b2Item.b2Path,
                    fileId: fileId
                )
            }
            // Clean up local files
            await self.stagingManager.removeStagingFile(for: b2Item.b2Path)
            self.removeCachedItem(for: b2Item.b2Path)
            replyHandler(nil)
        } catch {
            self.logger.error("removeItem failed: \(error)")
            replyHandler(fs_errorForPOSIXError(EIO))
        }
    }
}
```

**renameItem:**
```swift
func renameItem(_ item: FSItem, inDirectory sourceDirectory: FSItem, named sourceName: FSFileName,
                toDirectory destDirectory: FSItem, newName: FSFileName, overItem: FSItem?,
                replyHandler: ((any Error)?) -> Void) {
    guard let b2Item = item as? B2Item,
          let destParent = destDirectory as? B2Item else {
        replyHandler(fs_errorForPOSIXError(EINVAL))
        return
    }
    
    let newNameStr = newName.string
    let destPath = destParent.b2Path.isEmpty ? newNameStr : destParent.b2Path + "/" + newNameStr
    
    Task {
        do {
            guard let fileId = b2Item.b2FileId else {
                replyHandler(fs_errorForPOSIXError(EINVAL))
                return
            }
            
            try await self.b2Client.rename(
                bucketId: self.bucketId,
                sourceFileName: b2Item.b2Path,
                sourceFileId: fileId,
                destinationFileName: destPath
            )
            
            // Update cache
            self.removeCachedItem(for: b2Item.b2Path)
            b2Item.b2Path = destPath  // Note: b2Path may need to be var
            b2Item.name = newName
            self.cacheItem(b2Item)
            
            replyHandler(nil)
        } catch {
            self.logger.error("renameItem failed: \(error)")
            replyHandler(fs_errorForPOSIXError(EIO))
        }
    }
}
```

Note: For `b2Item.b2Path = destPath` to work, `b2Path` in B2Item must be declared as `var`, not `let`. If Plan 01 made it `let`, change it to `var` in this task.

**getAttributes:**
```swift
func getAttributes(_ attributes: FSItem.GetAttributesRequest, of item: FSItem,
                   replyHandler: (FSItem.Attributes?, (any Error)?) -> Void) {
    guard let b2Item = item as? B2Item else {
        replyHandler(nil, fs_errorForPOSIXError(EINVAL))
        return
    }
    replyHandler(makeAttributes(for: b2Item), nil)
}
```

**setAttributes:**
```swift
func setAttributes(_ newAttributes: FSItem.Attributes, on item: FSItem,
                   replyHandler: (FSItem.Attributes?, (any Error)?) -> Void) {
    // B2 doesn't support setting attributes (no chmod, chown, utimes)
    // Return current attributes unchanged
    guard let b2Item = item as? B2Item else {
        replyHandler(nil, fs_errorForPOSIXError(EINVAL))
        return
    }
    replyHandler(makeAttributes(for: b2Item), nil)
}
```

**reclaimItem:**
```swift
func reclaimItem(_ item: FSItem, replyHandler: ((any Error)?) -> Void) {
    if let b2Item = item as? B2Item {
        removeCachedItem(for: b2Item.b2Path)
    }
    replyHandler(nil)
}
```

**Update B2Volume.swift:** Remove all the Operations stub methods (lookupItem, enumerateDirectory, createItem, removeItem, renameItem, setAttributes, getAttributes, reclaimItem) since they now live in B2VolumeOperations.swift. Keep the ReadWrite/OpenClose stubs.

Also, move `makeAttributes(for:)` and `extractFileName(from:parentPath:)` helper methods to B2ItemAttributes.swift or B2VolumeOperations.swift — wherever makes more sense. If they're used across multiple files, put them in B2ItemAttributes.swift as an extension on B2Volume.
  </action>
  <verify>Build with `xcodebuild -scheme CloudMount build CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO 2>&1 | tail -10` — full project compiles with real volume operations</verify>
  <done>All FSVolume.Operations methods implemented with real B2Client calls; lookup resolves items via B2 directory listings; enumerate packs entries; create makes files (local placeholder) and directories (B2 marker); remove deletes from B2; rename does server-side copy+delete; metadata suppression active on lookup/create/remove</done>
</task>

</tasks>

<verification>
- `lookupItem` finds items by listing parent directory on B2 and matching name
- `enumerateDirectory` lists B2 directory contents and packs into FSDirectoryEntryPacker
- `createItem` for directories uploads B2 folder marker; for files creates local staging placeholder
- `removeItem` calls B2 delete API and cleans up local cache
- `renameItem` performs B2 copy + delete
- Suppressed metadata paths (.DS_Store, ._ files) handled without B2 API calls
- `getAttributes` returns correct type, mode, size, timestamps from B2Item
- Project builds successfully
</verification>

<success_criteria>
Volume supports all directory operations: users can browse directories (lookup + enumerate), create files and folders (create), delete items (remove), and rename/move items (rename). Metadata suppression prevents B2 API calls for Finder noise.
</success_criteria>

<output>
After completion, create `.planning/phases/06-fskit-filesystem/06-03-SUMMARY.md`
</output>
