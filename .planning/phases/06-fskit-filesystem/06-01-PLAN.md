---
phase: 06-fskit-filesystem
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - CloudMountExtension/B2Item.swift
  - CloudMountExtension/MetadataBlocklist.swift
  - CloudMountExtension/StagingManager.swift
autonomous: true

must_haves:
  truths:
    - "B2Item stores B2 path, bucket ID, file ID, staging URL, and dirty flag for every filesystem item"
    - "MetadataBlocklist correctly identifies .DS_Store, ._ files, .Spotlight-V100, .Trashes, .fseventsd, .TemporaryItems as suppressed"
    - "StagingManager creates, reads, writes, and cleans up per-item staging files in a temp directory"
  artifacts:
    - path: "CloudMountExtension/B2Item.swift"
      provides: "FSItem subclass with B2 metadata properties"
      contains: "class B2Item: FSItem"
    - path: "CloudMountExtension/MetadataBlocklist.swift"
      provides: "Static blocklist for macOS metadata path suppression"
      contains: "static func isSuppressed"
    - path: "CloudMountExtension/StagingManager.swift"
      provides: "Local temp file management for write staging"
      contains: "class StagingManager"
  key_links:
    - from: "CloudMountExtension/B2Item.swift"
      to: "CloudMountKit/B2/B2Types.swift"
      via: "imports B2FileInfo type for cached metadata"
      pattern: "import CloudMountKit"
    - from: "CloudMountExtension/StagingManager.swift"
      to: "Foundation FileManager"
      via: "creates temp directory and manages staging files"
      pattern: "FileManager.default"
---

<objective>
Create the three foundational types needed by the FSKit volume: B2Item (FSItem subclass tracking B2 metadata per file/directory), MetadataBlocklist (suppresses macOS metadata noise), and StagingManager (manages local temp files for write-on-close semantics).

Purpose: These types are the building blocks for all volume operations. B2Item is returned by every lookup/enumerate/create call. MetadataBlocklist is checked on every create/write/lookup to avoid B2 API calls for Finder noise. StagingManager handles the local file lifecycle for read caching and write staging.

Output: Three Swift files in CloudMountExtension/ that compile against FSKit and CloudMountKit.
</objective>

<execution_context>
@~/.config/Claude/get-shit-done/workflows/execute-plan.md
@~/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-fskit-filesystem/06-RESEARCH.md
@.planning/phases/06-fskit-filesystem/06-CONTEXT.md
@CloudMountKit/B2/B2Types.swift
@CloudMountKit/Cache/FileCache.swift
@CloudMountExtension/CloudMountExtension.swift
@project.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: B2Item FSItem subclass and MetadataBlocklist</name>
  <files>CloudMountExtension/B2Item.swift, CloudMountExtension/MetadataBlocklist.swift</files>
  <action>
Create `CloudMountExtension/B2Item.swift` — an FSItem subclass that stores B2-specific metadata for each file/directory in the virtual filesystem:

```swift
import FSKit
import CloudMountKit
```

Class `B2Item: FSItem` with these stored properties:
- `b2Path: String` — full B2 key path (e.g., "photos/vacation/img.jpg")
- `bucketId: String`
- `b2FileId: String?` — nil for inferred directories (no B2 file ID)
- `b2FileInfo: B2FileInfo?` — cached B2 metadata from list operations
- `localCacheURL: URL?` — non-nil when file content is cached locally (downloaded)
- `localStagingURL: URL?` — non-nil when file has uncommitted writes
- `isDirty: Bool` — true when local writes pending upload to B2
- `isDirectory: Bool` — true for directories
- `contentLength: Int64` — file size in bytes (0 for directories)
- `modificationTime: Date` — from B2 uploadTimestamp or current time for new items

Provide a convenience initializer:
```swift
init(name: FSFileName, identifier: FSItem.Identifier, b2Path: String, bucketId: String, isDirectory: Bool)
```
that calls `super.init()` and sets `self.name = name`, `self.identifier = identifier`, plus the B2 fields. Set `isDirty = false`, `contentLength = 0`, `modificationTime = Date()` as defaults.

Also provide a static factory:
```swift
static func fromB2FileInfo(_ info: B2FileInfo, identifier: FSItem.Identifier) -> B2Item
```
that creates a B2Item from a B2FileInfo, setting:
- `b2Path` from `info.fileName`
- `isDirectory` from `info.action == "folder"` or `info.fileName.hasSuffix("/")`
- `contentLength` from `info.contentLength.value`
- `modificationTime` from `Date(timeIntervalSince1970: Double(info.uploadTimestamp.value) / 1000.0)`
- `b2FileId` from `info.fileId`
- `b2FileInfo` = info
- name: extract the last path component from `info.fileName` (strip trailing "/" for dirs), wrap in `FSFileName(string:)`

Create `CloudMountExtension/MetadataBlocklist.swift` — a struct with static methods for identifying macOS metadata paths that should be silently suppressed:

```swift
struct MetadataBlocklist {
    private static let blockedNames: Set<String> = [
        ".DS_Store",
        ".Spotlight-V100",
        ".Trashes",
        ".fseventsd",
        ".TemporaryItems",
        ".VolumeIcon.icns",
        ".com.apple.timemachine.donotpresent",
    ]
    
    static func isSuppressed(_ name: String) -> Bool {
        // Exact match against blocklist
        if blockedNames.contains(name) { return true }
        // AppleDouble resource fork files start with "._"
        if name.hasPrefix("._") { return true }
        return false
    }
    
    static func isSuppressedPath(_ path: String) -> Bool {
        let components = path.split(separator: "/")
        return components.contains { isSuppressed(String($0)) }
    }
}
```

Make MetadataBlocklist `Sendable` (it's a pure static struct, so it is automatically).
  </action>
  <verify>Build with `xcodebuild -scheme CloudMount -target CloudMountExtension build CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO 2>&1 | tail -5` — should compile without errors (or verify files parse cleanly if full build has unrelated issues)</verify>
  <done>B2Item subclass exists with all B2 metadata properties and factory method; MetadataBlocklist correctly identifies all 7+ macOS metadata patterns including ._ prefix files</done>
</task>

<task type="auto">
  <name>Task 2: StagingManager for write-on-close temp files</name>
  <files>CloudMountExtension/StagingManager.swift</files>
  <action>
Create `CloudMountExtension/StagingManager.swift` — a class that manages local temporary files for the download-on-open / write-on-close pattern.

Use `actor StagingManager` for thread safety (FSKit calls come from multiple threads via Task {} blocks).

Properties:
- `private let stagingDirectory: URL` — base directory for all staging files (e.g., `~/Library/Caches/CloudMount/staging/`)
- `private var activeFiles: [String: URL]` — maps B2 path → local staging file URL

Init:
```swift
init(mountId: String) {
    let cacheDir = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).first!
    self.stagingDirectory = cacheDir
        .appendingPathComponent("CloudMount", isDirectory: true)
        .appendingPathComponent("staging", isDirectory: true)
        .appendingPathComponent(mountId, isDirectory: true)
    try? FileManager.default.createDirectory(at: stagingDirectory, withIntermediateDirectories: true)
}
```

Public methods:

1. `func stagingURL(for b2Path: String) -> URL` — returns the URL for a staging file (deterministic, based on path). Use a hash or sanitized path to avoid filesystem path issues. Register in activeFiles.

2. `func createStagingFile(for b2Path: String, initialData: Data?) throws -> URL` — creates a new staging file with optional initial content. Returns the URL. Registers it.

3. `func writeTo(b2Path: String, data: Data, offset: Int64) throws` — writes data at offset to the staging file. Uses FileHandle for seek + write.

4. `func readFrom(b2Path: String, offset: Int64, length: Int) throws -> Data` — reads length bytes from offset of the staging file. Uses FileHandle for seek + read.

5. `func removeStagingFile(for b2Path: String)` — deletes the staging file and removes from activeFiles.

6. `func cleanupAll()` — removes all staging files and the mount-specific staging directory.

7. `func hasStagingFile(for b2Path: String) -> Bool` — checks if a staging file exists.

For the staging URL generation, use a simple approach: replace `/` with `_` in the b2Path and use that as the filename. If paths can be very long, use a SHA-256 hash of the b2Path (like FileCache does). Either approach is fine — consistency matters more than the choice.

Important: FileHandle operations should handle the case where the file doesn't exist (throw a clear error). Use `FileHandle(forWritingTo:)` and `FileHandle(forReadingFrom:)`.
  </action>
  <verify>Build with `xcodebuild -scheme CloudMount -target CloudMountExtension build CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO 2>&1 | tail -5` — should compile</verify>
  <done>StagingManager actor compiles, provides staging file CRUD, uses deterministic URL generation, and cleans up on demand</done>
</task>

</tasks>

<verification>
- All three files exist in CloudMountExtension/
- B2Item is a subclass of FSItem with all required B2 metadata
- MetadataBlocklist.isSuppressed returns true for .DS_Store, ._foo, .Spotlight-V100, .Trashes, .fseventsd, .TemporaryItems
- StagingManager creates, reads, writes staging files
- Extension target compiles (may need full project build with CODE_SIGNING_REQUIRED=NO)
</verification>

<success_criteria>
Foundation types for the FSKit volume are ready: B2Item tracks per-item B2 state, MetadataBlocklist suppresses Finder noise, StagingManager manages temp files for the download/write/upload lifecycle.
</success_criteria>

<output>
After completion, create `.planning/phases/06-fskit-filesystem/06-01-SUMMARY.md`
</output>
