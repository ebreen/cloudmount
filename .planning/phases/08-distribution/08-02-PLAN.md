---
phase: 08-distribution
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - .github/workflows/ci.yml
  - .github/workflows/release.yml
  - scripts/create-dmg.sh
autonomous: true

must_haves:
  truths:
    - "PRs to main trigger a build+test job that catches compilation errors"
    - "Pushing a v* tag triggers the full release pipeline (build → sign → notarize → DMG → GitHub Release)"
    - "Release pipeline imports Developer ID certificate from GitHub Secrets into a temporary keychain"
    - "DMG is created with Applications symlink for drag-to-install"
    - "DMG is notarized (not just the .app) and stapled"
    - "Release requires manual approval before publishing"
    - "SHA-256 checksum is published alongside the DMG"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "PR build and test workflow"
      contains: "pull_request"
    - path: ".github/workflows/release.yml"
      provides: "Tag-triggered release pipeline with manual approval gate"
      contains: "push.*tags"
    - path: "scripts/create-dmg.sh"
      provides: "DMG creation script with Applications symlink"
      contains: "create-dmg"
  key_links:
    - from: ".github/workflows/ci.yml"
      to: "xcodebuild"
      via: "build and test steps with CODE_SIGNING_ALLOWED=NO"
      pattern: "CODE_SIGNING_ALLOWED.*NO"
    - from: ".github/workflows/release.yml"
      to: "scripts/create-dmg.sh"
      via: "DMG creation step invoking script"
      pattern: "create-dmg"
    - from: ".github/workflows/release.yml"
      to: "scripts/export-options.plist"
      via: "xcodebuild -exportArchive referencing plist"
      pattern: "export-options.plist"
    - from: ".github/workflows/release.yml"
      to: "GitHub Secrets"
      via: "Certificate import (BUILD_CERTIFICATE_BASE64, P12_PASSWORD)"
      pattern: "BUILD_CERTIFICATE_BASE64"
---

<objective>
Create CI/CD pipelines: PR build checks and tag-triggered release workflow with code signing, notarization, DMG packaging, and GitHub Release publishing.

Purpose: CI-01 (PR checks), CI-02 (release pipeline), CI-03 (certificate import), PKG-01 (code signing), PKG-02 (notarization), PKG-03 (DMG creation). This is the core automation that turns a version tag push into a downloadable, signed, notarized DMG on GitHub Releases.

Output: Two GitHub Actions workflows (ci.yml, release.yml) and a DMG creation helper script.
</objective>

<execution_context>
@~/.config/Claude/get-shit-done/workflows/execute-plan.md
@~/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-distribution/08-RESEARCH.md
@.planning/phases/08-distribution/08-CONTEXT.md

@project.yml
@CloudMount/Info.plist
@CloudMount/CloudMount.entitlements
@CloudMountExtension/CloudMountExtension.entitlements
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PR build+test CI workflow</name>
  <files>
    .github/workflows/ci.yml
  </files>
  <action>
    Create `.github/workflows/ci.yml` with the following:

    ```yaml
    name: CI
    on:
      pull_request:
        branches: [main]

    concurrency:
      group: ci-${{ github.ref }}
      cancel-in-progress: true

    jobs:
      build-and-test:
        runs-on: macos-26
        timeout-minutes: 30
        steps:
          - uses: actions/checkout@v5

          - name: Install xcodegen
            run: brew install xcodegen

          - name: Generate Xcode project
            run: xcodegen generate

          - name: Build
            run: |
              xcodebuild build \
                -project CloudMount.xcodeproj \
                -scheme CloudMount \
                -configuration Debug \
                CODE_SIGN_IDENTITY="-" \
                CODE_SIGNING_ALLOWED=NO

          - name: Test
            run: |
              xcodebuild test \
                -project CloudMount.xcodeproj \
                -scheme CloudMount \
                -configuration Debug \
                CODE_SIGN_IDENTITY="-" \
                CODE_SIGNING_ALLOWED=NO \
              || echo "::warning::Tests failed or no test targets found"
    ```

    Key decisions:
    - `macos-26` runner (public preview, ARM64) — required for macOS 26 SDK / FSKit
    - `CODE_SIGN_IDENTITY="-"` and `CODE_SIGNING_ALLOWED=NO` — no signing needed for PR checks
    - `concurrency` group cancels stale runs on same PR
    - Test step uses `|| echo warning` because the project may not have test targets yet — this prevents CI failure while still surfacing the issue
    - 30-minute timeout as safety net
  </action>
  <verify>
    Validate YAML syntax: `python3 -c "import yaml; yaml.safe_load(open('.github/workflows/ci.yml'))"` (or `ruby -ryaml -e "YAML.load_file('.github/workflows/ci.yml')"`)
  </verify>
  <done>
    `.github/workflows/ci.yml` exists with PR-triggered build+test job on macos-26 runner, no code signing, concurrency control.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create release workflow and DMG script</name>
  <files>
    .github/workflows/release.yml
    scripts/create-dmg.sh
  </files>
  <action>
    1. Create `scripts/create-dmg.sh` (make executable with `chmod +x`):

    ```bash
    #!/bin/bash
    set -euo pipefail

    # Usage: ./scripts/create-dmg.sh <app-path> <version> <output-dir>
    # Example: ./scripts/create-dmg.sh /path/to/CloudMount.app 2.0.0 ./dist

    APP_PATH="${1:?Usage: create-dmg.sh <app-path> <version> <output-dir>}"
    VERSION="${2:?Usage: create-dmg.sh <app-path> <version> <output-dir>}"
    OUTPUT_DIR="${3:?Usage: create-dmg.sh <app-path> <version> <output-dir>}"

    DMG_NAME="CloudMount-${VERSION}.dmg"
    mkdir -p "$OUTPUT_DIR"

    create-dmg \
      --volname "CloudMount" \
      --window-size 600 400 \
      --icon-size 100 \
      --icon "CloudMount.app" 150 190 \
      --app-drop-link 450 190 \
      --hide-extension "CloudMount.app" \
      --no-internet-enable \
      "${OUTPUT_DIR}/${DMG_NAME}" \
      "$(dirname "$APP_PATH")"

    echo "Created: ${OUTPUT_DIR}/${DMG_NAME}"
    ```

    2. Create `.github/workflows/release.yml`:

    The workflow has three jobs:
    - `build-sign-notarize`: Archives, signs, notarizes, creates DMG, uploads artifact
    - `publish`: Manual approval gate (environment: production), creates GitHub Release
    - `bump-cask`: Updates Homebrew Cask in tap repo after publish

    ```yaml
    name: Release
    on:
      push:
        tags:
          - 'v[0-9]+.[0-9]+.[0-9]+'

    permissions:
      contents: write

    jobs:
      build-sign-notarize:
        runs-on: macos-26
        timeout-minutes: 60
        outputs:
          version: ${{ steps.version.outputs.version }}
          dmg-name: ${{ steps.version.outputs.dmg-name }}
        steps:
          - uses: actions/checkout@v5

          - name: Extract version from tag
            id: version
            run: |
              VERSION="${GITHUB_REF_NAME#v}"
              echo "version=$VERSION" >> "$GITHUB_OUTPUT"
              echo "dmg-name=CloudMount-${VERSION}.dmg" >> "$GITHUB_OUTPUT"

          - name: Install tools
            run: brew install create-dmg xcodegen

          - name: Import code signing certificate
            env:
              BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
              P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
              KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
            run: |
              CERTIFICATE_PATH="$RUNNER_TEMP/build_certificate.p12"
              KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"

              echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode -o "$CERTIFICATE_PATH"

              security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
              security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
              security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

              security import "$CERTIFICATE_PATH" -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
              # CRITICAL: Without this, codesign cannot access the certificate
              security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
              security list-keychain -d user -s "$KEYCHAIN_PATH"

          - name: Generate Xcode project
            run: xcodegen generate

          - name: Set version in Info.plist
            run: |
              VERSION="${{ steps.version.outputs.version }}"
              /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" CloudMount/Info.plist
              /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" CloudMountExtension/Info.plist
              # Use run number as build number for monotonic increment
              /usr/libexec/PlistBuddy -c "Set :CFBundleVersion ${{ github.run_number }}" CloudMount/Info.plist
              /usr/libexec/PlistBuddy -c "Set :CFBundleVersion ${{ github.run_number }}" CloudMountExtension/Info.plist

          - name: Archive
            env:
              TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
            run: |
              xcodebuild archive \
                -project CloudMount.xcodeproj \
                -scheme CloudMount \
                -archivePath "$RUNNER_TEMP/CloudMount.xcarchive" \
                -configuration Release \
                CODE_SIGN_STYLE=Manual \
                DEVELOPMENT_TEAM="$TEAM_ID" \
                CODE_SIGN_IDENTITY="Developer ID Application"

          - name: Export archive
            env:
              TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
            run: |
              # Inject teamID into export options
              EXPORT_PLIST="$RUNNER_TEMP/export-options.plist"
              cp scripts/export-options.plist "$EXPORT_PLIST"
              /usr/libexec/PlistBuddy -c "Add :teamID string $TEAM_ID" "$EXPORT_PLIST"

              xcodebuild -exportArchive \
                -archivePath "$RUNNER_TEMP/CloudMount.xcarchive" \
                -exportPath "$RUNNER_TEMP/export" \
                -exportOptionsPlist "$EXPORT_PLIST"

          - name: Verify code signature
            run: |
              codesign --verify --deep --strict --verbose=2 "$RUNNER_TEMP/export/CloudMount.app"
              codesign -d --entitlements :- "$RUNNER_TEMP/export/CloudMount.app/Contents/PlugIns/CloudMountExtension.appex"

          - name: Create DMG
            run: |
              chmod +x scripts/create-dmg.sh
              ./scripts/create-dmg.sh \
                "$RUNNER_TEMP/export/CloudMount.app" \
                "${{ steps.version.outputs.version }}" \
                "$RUNNER_TEMP/dist"

          - name: Notarize DMG
            env:
              APP_STORE_CONNECT_KEY_BASE64: ${{ secrets.APP_STORE_CONNECT_KEY_BASE64 }}
              API_KEY_ID: ${{ secrets.API_KEY_ID }}
              API_ISSUER_ID: ${{ secrets.API_ISSUER_ID }}
            run: |
              echo -n "$APP_STORE_CONNECT_KEY_BASE64" | base64 --decode -o "$RUNNER_TEMP/AuthKey.p8"

              xcrun notarytool submit \
                "$RUNNER_TEMP/dist/${{ steps.version.outputs.dmg-name }}" \
                --key "$RUNNER_TEMP/AuthKey.p8" \
                --key-id "$API_KEY_ID" \
                --issuer "$API_ISSUER_ID" \
                --wait \
                --timeout 30m

              xcrun stapler staple "$RUNNER_TEMP/dist/${{ steps.version.outputs.dmg-name }}"

          - name: Verify notarization
            run: |
              xcrun stapler validate "$RUNNER_TEMP/dist/${{ steps.version.outputs.dmg-name }}"

          - name: Generate checksum
            run: |
              cd "$RUNNER_TEMP/dist"
              shasum -a 256 "${{ steps.version.outputs.dmg-name }}" > "${{ steps.version.outputs.dmg-name }}.sha256"

          - name: Upload release assets
            uses: actions/upload-artifact@v4
            with:
              name: release-assets
              path: |
                ${{ runner.temp }}/dist/${{ steps.version.outputs.dmg-name }}
                ${{ runner.temp }}/dist/${{ steps.version.outputs.dmg-name }}.sha256
              retention-days: 5

          - name: Clean up keychain
            if: ${{ always() }}
            run: |
              security delete-keychain "$RUNNER_TEMP/app-signing.keychain-db" 2>/dev/null || true
              rm -f "$RUNNER_TEMP/AuthKey.p8" "$RUNNER_TEMP/build_certificate.p12"

      publish:
        needs: build-sign-notarize
        runs-on: ubuntu-latest
        environment: production
        steps:
          - uses: actions/checkout@v5

          - name: Download release assets
            uses: actions/download-artifact@v4
            with:
              name: release-assets
              path: dist

          - name: Create GitHub Release
            uses: softprops/action-gh-release@v2
            with:
              tag_name: ${{ github.ref_name }}
              name: CloudMount ${{ needs.build-sign-notarize.outputs.version }}
              files: |
                dist/${{ needs.build-sign-notarize.outputs.dmg-name }}
                dist/${{ needs.build-sign-notarize.outputs.dmg-name }}.sha256
              draft: false
              prerelease: false
              generate_release_notes: false
              body: |
                ## CloudMount ${{ needs.build-sign-notarize.outputs.version }}

                ### Installation

                **Download:** `${{ needs.build-sign-notarize.outputs.dmg-name }}` — open the DMG and drag CloudMount to Applications.

                **Homebrew:** `brew install eirikbreen/cloudmount/cloudmount`

                ### Requirements

                - macOS 26 (Tahoe) or later
                - Enable the FSKit extension in System Settings → General → Login Items & Extensions

                ### Checksums

                SHA-256 checksum available in `${{ needs.build-sign-notarize.outputs.dmg-name }}.sha256`

      bump-cask:
        needs: [build-sign-notarize, publish]
        runs-on: ubuntu-latest
        steps:
          - uses: actions/checkout@v5

          - name: Download checksum
            uses: actions/download-artifact@v4
            with:
              name: release-assets
              path: dist

          - name: Bump Homebrew Cask
            env:
              TAP_GITHUB_TOKEN: ${{ secrets.TAP_GITHUB_TOKEN }}
              VERSION: ${{ needs.build-sign-notarize.outputs.version }}
              DMG_NAME: ${{ needs.build-sign-notarize.outputs.dmg-name }}
            run: |
              SHA256=$(awk '{print $1}' "dist/${DMG_NAME}.sha256")

              git clone "https://x-access-token:${TAP_GITHUB_TOKEN}@github.com/eirikbreen/homebrew-cloudmount.git" tap
              cd tap

              cat > Casks/cloudmount.rb << CASK
              cask "cloudmount" do
                version "${VERSION}"
                sha256 "${SHA256}"

                url "https://github.com/eirikbreen/cloudmount/releases/download/v#{version}/CloudMount-#{version}.dmg"
                name "CloudMount"
                desc "Mount cloud storage as native macOS volumes via FSKit"
                homepage "https://github.com/eirikbreen/cloudmount"

                livecheck do
                  url :url
                  strategy :github_latest
                end

                auto_updates true
                depends_on macos: ">= :tahoe"

                app "CloudMount.app"

                zap trash: [
                  "~/Library/Application Support/com.cloudmount.app",
                  "~/Library/Caches/com.cloudmount.app",
                  "~/Library/HTTPStorages/com.cloudmount.app",
                  "~/Library/Preferences/com.cloudmount.app.plist",
                  "~/Library/Saved Application State/com.cloudmount.app.savedState",
                ]

                caveats <<~EOS
                  CloudMount requires macOS 26 (Tahoe) or later.

                  After installation, enable the FSKit extension:
                    System Settings → General → Login Items & Extensions → CloudMount

                  Mount a volume:  Use the CloudMount menu bar app, or run: mount -t b2 b2://bucket /mount/point
                  Unmount:          Use the menu bar app, or run: diskutil unmount /mount/point

                  For help: https://github.com/eirikbreen/cloudmount
                EOS
              end
              CASK

              git config user.name "github-actions[bot]"
              git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
              git add Casks/cloudmount.rb
              git commit -m "bump cloudmount to ${VERSION}"
              git push
    ```

    Key design decisions:
    - **Three separate jobs:** build-sign-notarize (heavy lifting) → publish (manual gate via `environment: production`) → bump-cask (automated after publish)
    - **App Store Connect API Key** for notarization (avoids 2FA issues vs Apple ID)
    - **Notarize the DMG** (not just the .app) per research pitfall guidance
    - **teamID injected at CI time** via PlistBuddy into a copy of export-options.plist — avoids committing personal team ID
    - **`github.run_number`** for CFBundleVersion — monotonically increasing integer for Sparkle
    - **Keychain cleanup with `if: always()`** — prevents key leakage on self-hosted runners
    - **fail-closed:** no `continue-on-error` — any failure stops the pipeline
    - **GitHub Secrets required:** BUILD_CERTIFICATE_BASE64, P12_PASSWORD, KEYCHAIN_PASSWORD, APPLE_TEAM_ID, APP_STORE_CONNECT_KEY_BASE64, API_KEY_ID, API_ISSUER_ID, TAP_GITHUB_TOKEN
  </action>
  <verify>
    1. Validate YAML syntax: `python3 -c "import yaml; yaml.safe_load(open('.github/workflows/release.yml'))"`
    2. Verify DMG script is executable: `test -x scripts/create-dmg.sh`
    3. Verify all GitHub Secret references are consistent between the workflow jobs
  </verify>
  <done>
    `.github/workflows/release.yml` exists with 3-job pipeline (build-sign-notarize → publish with manual gate → bump-cask). `scripts/create-dmg.sh` is executable. Certificate import includes `set-key-partition-list`. DMG is notarized+stapled. SHA-256 checksum generated.
  </done>
</task>

</tasks>

<verification>
1. `.github/workflows/ci.yml` — valid YAML, triggers on `pull_request`, uses `macos-26`, runs `xcodebuild build` and `xcodebuild test` with no code signing
2. `.github/workflows/release.yml` — valid YAML, triggers on `v*` tags, has build-sign-notarize + publish (environment: production) + bump-cask jobs
3. `scripts/create-dmg.sh` — executable, uses `create-dmg` with `--app-drop-link` for Applications symlink
4. Certificate import step includes `security set-key-partition-list` (critical per research)
5. Notarization targets the DMG (not just .app)
6. Keychain cleanup uses `if: ${{ always() }}`
7. No hardcoded signing identities or team IDs — all from secrets/env vars
</verification>

<success_criteria>
- ci.yml triggers on PRs, builds and tests without code signing
- release.yml triggers on v* tags, performs full archive → sign → notarize → DMG → release flow
- Manual approval gate (environment: production) before GitHub Release publish
- DMG notarized and stapled, SHA-256 checksum alongside
- Homebrew Cask auto-bumped after successful release publish
- All signing credentials sourced from GitHub Secrets (no committed secrets)
</success_criteria>

<output>
After completion, create `.planning/phases/08-distribution/08-02-SUMMARY.md`
</output>
