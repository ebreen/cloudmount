---
phase: 02-core-mount-browse
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  "Daemon/CloudMountDaemon/Cargo.toml",
  "Daemon/CloudMountDaemon/src/main.rs",
  "Daemon/CloudMountDaemon/src/fs/mod.rs",
  "Daemon/CloudMountDaemon/src/fs/b2fs.rs",
  "Daemon/CloudMountDaemon/src/fs/inode.rs",
  "Daemon/CloudMountDaemon/src/b2/mod.rs",
  "Daemon/CloudMountDaemon/src/b2/types.rs"
]
autonomous: true

must_haves:
  truths:
    - "Rust daemon project structure exists with Cargo.toml"
    - "FUSE filesystem trait is implemented for B2 buckets"
    - "getattr returns correct file attributes for inodes"
    - "readdir lists directory contents from B2 API"
    - "Inode table maps paths to stable inode numbers"
  artifacts:
    - path: "Daemon/CloudMountDaemon/Cargo.toml"
      provides: "Rust dependencies (fuser, tokio, reqwest, moka, serde)"
    - path: "Daemon/CloudMountDaemon/src/fs/b2fs.rs"
      provides: "B2Filesystem implementing fuser::Filesystem trait"
      exports: ["B2Filesystem", "getattr", "readdir", "lookup"]
    - path: "Daemon/CloudMountDaemon/src/fs/inode.rs"
      provides: "Inode table for path-to-inode mapping"
      exports: ["InodeTable", "lookup_or_create", "get_path"]
    - path: "Daemon/CloudMountDaemon/src/b2/types.rs"
      provides: "B2 API types (FileInfo, ListFilesResponse)"
  key_links:
    - from: "fs/b2fs.rs"
      to: "fs/inode.rs"
      via: "InodeTable usage"
      pattern: "inode_table.lookup_or_create"
    - from: "fs/b2fs.rs"
      to: "b2/types.rs"
      via: "FileInfo conversion to FileAttr"
      pattern: "b2_file_to_attr"
---

<objective>
Create the Rust daemon foundation with FUSE filesystem implementation supporting getattr and readdir operations for Backblaze B2 buckets.

Purpose: This is the core filesystem layer that translates B2 bucket contents into a FUSE filesystem that macOS can mount. Without this, there is no filesystem to mount.

Output: A compilable Rust daemon with FUSE trait implementation, inode management, and B2 type definitions.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-mount-browse/02-RESEARCH.md

# Swift UI exists from Phase 1
@Sources/CloudMount/CloudMountApp.swift
@Sources/CloudMount/MenuContentView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Rust daemon project with dependencies</name>
  <files>
    Daemon/CloudMountDaemon/Cargo.toml
    Daemon/CloudMountDaemon/src/main.rs
  </files>
  <action>
Create the Rust daemon project structure:

1. Create directory `Daemon/CloudMountDaemon/` with standard Rust layout
2. Create `Cargo.toml` with these exact dependencies (from RESEARCH.md):
   - fuser = "0.16"
   - tokio = { version = "1.40", features = ["rt-multi-thread", "macros", "net"] }
   - moka = { version = "0.12", features = ["future"] }
   - reqwest = { version = "0.12", features = ["json", "rustls-tls"] }
   - serde = { version = "1.0", features = ["derive"] }
   - tracing = "0.1"
   - anyhow = "1.0"
   - nix = { version = "0.29", features = ["net"] }

3. Create `src/main.rs` with basic daemon structure:
   - Tokio runtime initialization
   - Placeholder for filesystem mount
   - Basic logging setup with tracing

4. Create module directories: `src/fs/`, `src/b2/`, `src/cache/`, `src/ipc/`, `src/mount/`

IMPORTANT: Use exact versions from RESEARCH.md. These are verified working versions.
  </action>
  <verify>
cd Daemon/CloudMountDaemon && cargo check
  </verify>
  <done>
Cargo.toml exists with all dependencies, cargo check passes with no errors, project structure created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement inode table for path-to-inode mapping</name>
  <files>
    Daemon/CloudMountDaemon/src/fs/inode.rs
    Daemon/CloudMountDaemon/src/fs/mod.rs
  </files>
  <action>
Implement the inode management module (from RESEARCH.md Pattern 2):

1. Create `src/fs/inode.rs` with `InodeTable` struct:
   - Use HashMap<String, u64> for path_to_ino mapping
   - Use HashMap<u64, String> for ino_to_path mapping
   - ROOT_INO constant = 1
   - next_ino counter starting at 2

2. Implement methods:
   - `new()` - initializes with root inode (path "" -> ino 1)
   - `lookup_or_create(path: &str) -> u64` - returns existing or creates new inode
   - `get_path(ino: u64) -> Option<&str>` - reverse lookup
   - `get_ino(path: &str) -> Option<u64>` - forward lookup (no create)

3. Thread safety: Wrap inodes in Arc<Mutex<>> or use concurrent HashMap
   - InodeTable itself doesn't need to be Send/Sync (fuser is single-threaded)
   - But use parking_lot::Mutex for better performance if needed

4. Create `src/fs/mod.rs` that exports inode module

CRITICAL: Inode numbers must be STABLE for the lifetime of the mount. Never recycle inodes.
  </action>
  <verify>
cd Daemon/CloudMountDaemon && cargo check --lib
  </verify>
  <done>
InodeTable compiles with all methods, root inode (1) maps to empty path, lookup_or_create returns stable inodes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement B2 API types and FileAttr conversion</name>
  <files>
    Daemon/CloudMountDaemon/src/b2/types.rs
    Daemon/CloudMountDaemon/src/b2/mod.rs
  </files>
  <action>
Create B2 API types for filesystem operations (from RESEARCH.md Pattern 5):

1. Create `src/b2/types.rs` with serde-derived structs:
   ```rust
   #[derive(Deserialize)]
   pub struct FileInfo {
       pub file_name: String,
       pub content_length: u64,
       pub upload_timestamp: u64, // milliseconds
       pub action: String,        // "upload", "folder", etc.
   }

   #[derive(Deserialize)]
   pub struct ListFilesResponse {
       pub files: Vec<FileInfo>,
       pub next_file_name: Option<String>,
   }
   ```

2. Add conversion function `b2_file_to_attr(ino: u64, file: &FileInfo) -> FileAttr`:
   - Convert upload_timestamp (ms) to SystemTime
   - Set FileType::Directory if action == "folder", else FileType::RegularFile
   - Set permissions: 0o755 for directories, 0o644 for files
   - Set uid/gid to current user (501/20 typical on macOS)
   - Calculate blocks: (content_length + 511) / 512
   - Set blksize to 4096
   - atime = mtime = ctime = crtime = upload time (B2 doesn't track access time)

3. Create `src/b2/mod.rs` that exports types module

4. Add DirEntry struct for readdir results:
   ```rust
   pub struct DirEntry {
       pub name: String,
       pub ino: u64,
       pub kind: FileType,
   }
   ```

Use fuser::FileAttr and fuser::FileType from the fuser crate.
  </action>
  <verify>
cd Daemon/CloudMountDaemon && cargo check --lib
  </verify>
  <done>
B2 types compile, FileAttr conversion produces valid attributes with correct timestamps and permissions.
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement FUSE filesystem trait with getattr and readdir</name>
  <files>
    Daemon/CloudMountDaemon/src/fs/b2fs.rs
    Daemon/CloudMountDaemon/src/fs/mod.rs
  </files>
  <action>
Implement the core FUSE filesystem (from RESEARCH.md Pattern 1):

1. Create `B2Filesystem` struct in `src/fs/b2fs.rs`:
   ```rust
   pub struct B2Filesystem {
       inode_table: InodeTable,
       // Stub B2 client - will be implemented in 02-02
       bucket_id: String,
   }
   ```

2. Implement `fuser::Filesystem` trait with these methods:

   **getattr** - Get file attributes:
   - Look up inode in inode_table to get path
   - For root (ino 1): Return directory attributes with current time
   - For other inodes: Return stub attributes (full B2 integration in next plan)
   - Use reply.attr() with TTL of 1 second

   **lookup** - Look up file by name:
   - Resolve parent inode to path prefix
   - Construct full path: "{prefix}/{name}"
   - Get or create inode for path
   - Return FileAttr (stub for now)

   **readdir** - Read directory contents:
   - Resolve inode to path prefix
   - Return entries: "." (ino), ".." (parent ino or 1), and stub entries
   - Use reply.add() for each entry with offset
   - Finish with reply.ok()

3. Implement helper methods:
   - `new(bucket_id: String) -> Self`
   - `get_attr_for_inode(&self, ino: u64) -> Option<FileAttr>`

4. Update `src/fs/mod.rs` to export b2fs module

IMPORTANT: This is a STUB implementation - getattr and readdir return placeholder data. Real B2 API calls come in 02-02. The goal is to have a compilable FUSE filesystem that can be mounted.
  </action>
  <verify>
cd Daemon/CloudMountDaemon && cargo check --lib
  </verify>
  <done>
B2Filesystem implements Filesystem trait with getattr, lookup, and readdir methods, compiles without errors.
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
- [ ] `cargo check` passes in Daemon/CloudMountDaemon/
- [ ] All modules compile: fs, b2
- [ ] InodeTable has stable path-to-inode mapping
- [ ] B2Filesystem implements fuser::Filesystem trait
- [ ] FileAttr conversion handles directories and files correctly
</verification>

<success_criteria>
1. Rust daemon project exists with all dependencies from RESEARCH.md
2. InodeTable provides stable inode mapping (path -> ino, ino -> path)
3. B2 API types defined with serde deserialization
4. FileAttr conversion produces valid filesystem attributes
5. B2Filesystem implements getattr, lookup, and readdir FUSE methods
6. Code compiles with `cargo check` (stub B2 client is acceptable)
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-mount-browse/02-01-SUMMARY.md`
</output>
