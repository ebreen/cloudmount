---
phase: 02-core-mount-browse
plan: 04
type: execute
wave: 2
depends_on: ["02-01", "02-02", "02-03"]
files_modified: [
  "Daemon/CloudMountDaemon/src/ipc/server.rs",
  "Daemon/CloudMountDaemon/src/ipc/mod.rs",
  "Daemon/CloudMountDaemon/src/ipc/protocol.rs",
  "Daemon/CloudMountDaemon/src/main.rs",
  "Sources/CloudMount/DaemonClient.swift",
  "Sources/CloudMount/AppState.swift",
  "Sources/CloudMount/MenuContentView.swift"
]
autonomous: false
user_setup: []

must_haves:
  truths:
    - "Swift UI can send mount command to Rust daemon via Unix socket"
    - "Swift UI can send unmount command to Rust daemon"
    - "Swift UI receives mount status updates from daemon"
    - "Status bar menu shows list of mounted buckets"
    - "One-click unmount works from status bar menu"
  artifacts:
    - path: "Daemon/CloudMountDaemon/src/ipc/server.rs"
      provides: "Unix socket IPC server for Swift communication"
      exports: ["IpcServer", "run"]
    - path: "Daemon/CloudMountDaemon/src/ipc/protocol.rs"
      provides: "JSON protocol definitions for commands"
    - path: "Sources/CloudMount/DaemonClient.swift"
      provides: "Swift client for daemon IPC"
      exports: ["DaemonClient", "mount", "unmount", "getStatus"]
    - path: "Sources/CloudMount/AppState.swift"
      provides: "Updated AppState with mount status tracking"
  key_links:
    - from: "DaemonClient.swift"
      to: "ipc/server.rs"
      via: "Unix domain socket at /tmp/cloudmount.sock"
      pattern: "JSON commands over Unix socket"
    - from: "MenuContentView.swift"
      to: "AppState.swift"
      via: "Mount status observation"
      pattern: "@EnvironmentObject var appState"
    - from: "AppState.swift"
      to: "DaemonClient.swift"
      via: "Mount/unmount commands"
      pattern: "daemonClient.mount(...)"
---

<objective>
Build Unix socket IPC layer between Swift UI and Rust daemon, enabling mount/unmount control and status display in the status bar menu.

Purpose: This connects the Swift UI (Phase 1) with the Rust daemon (02-01/02/03), completing the end-to-end user experience for mounting and browsing buckets.

Output: Bidirectional IPC with mount/unmount commands and status updates, integrated into the status bar menu.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-mount-browse/02-RESEARCH.md

# Swift UI from Phase 1
@Sources/CloudMount/CloudMountApp.swift
@Sources/CloudMount/MenuContentView.swift
@Sources/CloudMount/CredentialStore.swift

# Prior plans (when available)
@.planning/phases/02-core-mount-browse/02-01-SUMMARY.md
@.planning/phases/02-core-mount-browse/02-02-SUMMARY.md
@.planning/phases/02-core-mount-browse/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define IPC protocol with JSON serialization</name>
  <files>
    Daemon/CloudMountDaemon/src/ipc/protocol.rs
    Daemon/CloudMountDaemon/src/ipc/mod.rs
  </files>
  <action>
Define the JSON protocol for Swift-Rust communication (from RESEARCH.md Pattern 4):

1. Create `src/ipc/protocol.rs` with command/response types:
   ```rust
   use serde::{Deserialize, Serialize};

   // Commands from Swift to Rust
   #[derive(Serialize, Deserialize, Debug)]
   #[serde(tag = "type")]
   pub enum Command {
       Mount {
           bucket_id: String,
           mountpoint: String,
           key_id: String,
           key: String,
       },
       Unmount {
           bucket_id: String,
       },
       GetStatus,
       ListMounts,
   }

   // Responses from Rust to Swift
   #[derive(Serialize, Deserialize, Debug)]
   #[serde(tag = "type")]
   pub enum Response {
       Success { message: String },
       Error { code: String, message: String },
       Status {
           mounts: Vec<MountInfo>,
       },
       MountList {
           mounts: Vec<MountInfo>,
       },
   }

   #[derive(Serialize, Deserialize, Debug, Clone)]
   pub struct MountInfo {
       pub bucket_id: String,
       pub mountpoint: String,
       pub mounted: bool,
   }
   ```

2. Add protocol versioning for future compatibility:
   ```rust
   pub const PROTOCOL_VERSION: u32 = 1;

   #[derive(Serialize, Deserialize)]
   pub struct Envelope {
       pub version: u32,
       pub command: Command,
   }
   ```

3. Create `src/ipc/mod.rs` exporting protocol module

4. Add helper functions:
   - `parse_command(data: &[u8]) -> Result<Command, Error>`
   - `serialize_response(response: Response) -> Vec<u8>`

Use JSON for human-readable debugging. Consider bincode later if performance becomes an issue.
  </action>
  <verify>
cd Daemon/CloudMountDaemon && cargo check --lib
  </verify>
  <done>
Protocol types compile with serde derives, Command and Response enums defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement IPC server in Rust daemon</name>
  <files>
    Daemon/CloudMountDaemon/src/ipc/server.rs
    Daemon/CloudMountDaemon/src/ipc/mod.rs
    Daemon/CloudMountDaemon/src/main.rs
  </files>
  <action>
Implement the Unix socket IPC server (from RESEARCH.md Pattern 4):

1. Create `src/ipc/server.rs` with `IpcServer` struct:
   ```rust
   use tokio::net::{UnixListener, UnixStream};
   use tokio::io::{AsyncReadExt, AsyncWriteExt};
   use std::path::Path;
   use std::sync::Arc;

   pub struct IpcServer {
       socket_path: String,
       mount_manager: Arc<MountManager>,
   }

   impl IpcServer {
       pub fn new(socket_path: String, mount_manager: Arc<MountManager>) -> Self {
           Self { socket_path, mount_manager }
       }

       pub async fn run(&self) -> anyhow::Result<()> {
           // Remove old socket if exists
           let _ = std::fs::remove_file(&self.socket_path);
           
           let listener = UnixListener::bind(&self.socket_path)?;
           tracing::info!("IPC server listening on {}", self.socket_path);

           loop {
               let (stream, _) = listener.accept().await?;
               let manager = self.mount_manager.clone();
               tokio::spawn(handle_connection(stream, manager));
           }
       }
   }
   ```

2. Implement connection handler:
   ```rust
   async fn handle_connection(mut stream: UnixStream, manager: Arc<MountManager>) {
       let mut buf = vec![0u8; 4096];
       
       match stream.read(&mut buf).await {
           Ok(n) if n > 0 => {
               let response = process_command(&buf[..n], manager).await;
               let response_json = serde_json::to_vec(&response).unwrap_or_default();
               let _ = stream.write_all(&response_json).await;
           }
           _ => {}
       }
   }

   async fn process_command(data: &[u8], manager: Arc<MountManager>) -> Response {
       match parse_command(data) {
           Ok(Command::Mount { bucket_id, mountpoint, key_id, key }) => {
               // Authorize with B2
               match B2Client::authorize_account(&key_id, &key).await {
                   Ok(client) => {
                       let path = std::path::PathBuf::from(&mountpoint);
                       match manager.mount(bucket_id.clone(), path, client).await {
                           Ok(_) => Response::Success { 
                               message: format!("Mounted {} at {}", bucket_id, mountpoint) 
                           },
                           Err(e) => Response::Error { 
                               code: "MOUNT_FAILED".to_string(), 
                               message: e.to_string() 
                           },
                       }
                   }
                   Err(e) => Response::Error { 
                       code: "AUTH_FAILED".to_string(), 
                       message: e.to_string() 
                   },
               }
           }
           Ok(Command::Unmount { bucket_id }) => {
               match manager.unmount(&bucket_id).await {
                   Ok(_) => Response::Success { 
                       message: format!("Unmounted {}", bucket_id) 
                   },
                   Err(e) => Response::Error { 
                       code: "UNMOUNT_FAILED".to_string(), 
                       message: e.to_string() 
                   },
               }
           }
           Ok(Command::GetStatus) => {
               let mounts = manager.list_mounts().await;
               Response::Status { mounts }
           }
           Ok(Command::ListMounts) => {
               let mounts = manager.list_mounts().await;
               Response::MountList { mounts }
           }
           Err(e) => Response::Error { 
               code: "INVALID_COMMAND".to_string(), 
               message: e.to_string() 
           },
       }
   }
   ```

3. Update `main.rs` to start IPC server:
   - Create MountManager as Arc<MountManager>
   - Spawn IPC server task
   - Keep main thread alive with signal handling

4. Set socket path: `/tmp/cloudmount.sock` or `~/Library/CloudMount/daemon.sock`

CRITICAL: Handle concurrent connections properly. Each connection spawns a new task.
  </action>
  <verify>
cd Daemon/CloudMountDaemon && cargo build
  </verify>
  <done>
IPC server compiles, handles all command types, integrates with MountManager.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Swift DaemonClient for IPC communication</name>
  <files>
    Sources/CloudMount/DaemonClient.swift
  </files>
  <action>
Implement the Swift client for communicating with the Rust daemon:

1. Create `Sources/CloudMount/DaemonClient.swift`:
   ```swift
   import Foundation

   enum DaemonError: Error {
       case connectionFailed
       case invalidResponse
       case daemonError(code: String, message: String)
   }

   struct MountInfo: Codable {
       let bucketId: String
       let mountpoint: String
       let mounted: Bool
   }

   struct Command: Codable {
       let type: String
       let bucketId: String?
       let mountpoint: String?
       let keyId: String?
       let key: String?
   }

   struct Response: Codable {
       let type: String
       let message: String?
       let code: String?
       let mounts: [MountInfo]?
   }

   actor DaemonClient {
       static let shared = DaemonClient()
       private let socketPath = "/tmp/cloudmount.sock"
       
       private init() {}
       
       // MARK: - Public API
       
       func mount(bucketId: String, mountpoint: String, keyId: String, key: String) async throws {
           let command = Command(
               type: "Mount",
               bucketId: bucketId,
               mountpoint: mountpoint,
               keyId: keyId,
               key: key
           )
           let response = try await sendCommand(command)
           if response.type == "Error" {
               throw DaemonError.daemonError(
                   code: response.code ?? "UNKNOWN",
                   message: response.message ?? "Unknown error"
               )
           }
       }
       
       func unmount(bucketId: String) async throws {
           let command = Command(
               type: "Unmount",
               bucketId: bucketId,
               mountpoint: nil,
               keyId: nil,
               key: nil
           )
           let response = try await sendCommand(command)
           if response.type == "Error" {
               throw DaemonError.daemonError(
                   code: response.code ?? "UNKNOWN",
                   message: response.message ?? "Unknown error"
               )
           }
       }
       
       func getStatus() async throws -> [MountInfo] {
           let command = Command(
               type: "GetStatus",
               bucketId: nil,
               mountpoint: nil,
               keyId: nil,
               key: nil
           )
           let response = try await sendCommand(command)
           return response.mounts ?? []
       }
       
       // MARK: - Private
       
       private func sendCommand(_ command: Command) async throws -> Response {
           let data = try JSONEncoder().encode(command)
           
           return try await withCheckedThrowingContinuation { continuation in
               DispatchQueue.global(qos: .userInitiated).async {
                   do {
                       // Connect to Unix socket
                       var address = sockaddr_un()
                       address.sun_family = sa_family_t(AF_UNIX)
                       strncpy(&address.sun_path.0, self.socketPath, Int(PATH_MAX))
                       
                       let fd = socket(AF_UNIX, SOCK_STREAM, 0)
                       guard fd >= 0 else {
                           continuation.resume(throwing: DaemonError.connectionFailed)
                           return
                       }
                       
                       let connectResult = withUnsafePointer(to: &address) { ptr in
                           ptr.withMemoryRebound(to: sockaddr.self, capacity: 1) { addrPtr in
                               connect(fd, addrPtr, socklen_t(MemoryLayout<sockaddr_un>.size))
                           }
                       }
                       
                       guard connectResult == 0 else {
                           close(fd)
                           continuation.resume(throwing: DaemonError.connectionFailed)
                           return
                       }
                       
                       // Send command
                       _ = data.withUnsafeBytes { ptr in
                           write(fd, ptr.baseAddress, ptr.count)
                       }
                       
                       // Read response
                       var responseData = Data()
                       var buffer = [UInt8](repeating: 0, count: 4096)
                       while true {
                           let bytesRead = read(fd, &buffer, buffer.count)
                           if bytesRead <= 0 { break }
                           responseData.append(contentsOf: buffer[0..<bytesRead])
                       }
                       
                       close(fd)
                       
                       // Parse response
                       let response = try JSONDecoder().decode(Response.self, from: responseData)
                       continuation.resume(returning: response)
                       
                   } catch {
                       continuation.resume(throwing: DaemonError.invalidResponse)
                   }
               }
           }
       }
   }
   ```

2. Use Swift actor for thread-safe singleton

3. Handle socket path properly with Foundation if possible, or use low-level BSD sockets as shown

Alternative: Use `URLSession` with a custom `URLProtocol` or use `Process` to call a helper. But BSD sockets are straightforward for Unix domain sockets.
  </action>
  <verify>
swift build 2>&1 | head -50
  </verify>
  <done>
DaemonClient.swift compiles, has mount/unmount/getStatus methods, uses JSON over Unix socket.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update Swift UI with mount status and controls</name>
  <files>
    Sources/CloudMount/AppState.swift
    Sources/CloudMount/MenuContentView.swift
    Sources/CloudMount/CloudMountApp.swift
  </files>
  <action>
Update Swift UI to integrate with daemon and show mount status:

1. Create `Sources/CloudMount/AppState.swift` (extract from CloudMountApp.swift):
   ```swift
   import SwiftUI

   @MainActor
   final class AppState: ObservableObject {
       @Published var macFUSEInstalled: Bool = false
       @Published var isCheckingMacFUSE: Bool = false
       @Published var storedBuckets: [BucketInfo] = []
       @Published var isDaemonRunning: Bool = false
       
       private let daemonClient = DaemonClient.shared
       private var statusTimer: Timer?
       
       init() {
           checkMacFUSE()
           startStatusUpdates()
       }
       
       func checkMacFUSE() {
           isCheckingMacFUSE = true
           macFUSEInstalled = MacFUSEDetector.isInstalled()
           isCheckingMacFUSE = false
       }
       
       func startStatusUpdates() {
           // Check daemon status every 2 seconds
           statusTimer = Timer.scheduledTimer(withTimeInterval: 2.0, repeats: true) { _ in
               Task { @MainActor in
                   await self.updateMountStatus()
               }
           }
       }
       
       func updateMountStatus() async {
           do {
               let mounts = try await daemonClient.getStatus()
               isDaemonRunning = true
               
               // Update bucket list with mount status
               for (index, var bucket) in storedBuckets.enumerated() {
                   if let mountInfo = mounts.first(where: { $0.bucketId == bucket.id }) {
                       storedBuckets[index].isMounted = mountInfo.mounted
                   }
               }
           } catch {
               isDaemonRunning = false
           }
       }
       
       func mountBucket(_ bucket: BucketInfo) async {
           guard let credentials = try? CredentialStore.shared.getCredentials(for: bucket.id) else {
               return
           }
           
           do {
               try await daemonClient.mount(
                   bucketId: bucket.id,
                   mountpoint: bucket.mountpoint,
                   keyId: credentials.keyId,
                   key: credentials.key
               )
               await updateMountStatus()
           } catch {
               // Show error alert
               print("Mount failed: \(error)")
           }
       }
       
       func unmountBucket(_ bucket: BucketInfo) async {
           do {
               try await daemonClient.unmount(bucketId: bucket.id)
               await updateMountStatus()
           } catch {
               print("Unmount failed: \(error)")
           }
       }
   }

   struct BucketInfo: Identifiable {
       let id: String
       var mountpoint: String
       var isMounted: Bool = false
   }
   ```

2. Update `MenuContentView.swift` to show mount controls:
   - Replace "Not mounted" text with toggle button
   - Show "Mount" / "Unmount" button based on isMounted state
   - Add visual indicator (green dot) for mounted buckets
   - Show daemon connection status in header

3. Update `CloudMountApp.swift`:
   - Move AppState to separate file
   - Import and use updated AppState

4. Update `bucketsSection` in MenuContentView:
   ```swift
   private var bucketsSection: some View {
       VStack(alignment: .leading, spacing: 8) {
           Text("BUCKETS")
               .font(.caption)
               .fontWeight(.semibold)
               .foregroundStyle(.tertiary)
           
           if appState.storedBuckets.isEmpty {
               Text("No buckets configured")
                   .font(.subheadline)
                   .foregroundStyle(.secondary)
                   .padding(.vertical, 4)
           } else {
               ForEach(appState.storedBuckets) { bucket in
                   HStack {
                       Image(systemName: bucket.isMounted ? "externaldrive.fill" : "folder.fill")
                           .foregroundStyle(bucket.isMounted ? .green : .blue)
                       Text(bucket.id)
                           .font(.subheadline)
                       Spacer()
                       Button(bucket.isMounted ? "Unmount" : "Mount") {
                           Task {
                               if bucket.isMounted {
                                   await appState.unmountBucket(bucket)
                               } else {
                                   await appState.mountBucket(bucket)
                               }
                           }
                       }
                       .buttonStyle(.bordered)
                       .controlSize(.small)
                       .disabled(!appState.macFUSEInstalled)
                   }
               }
           }
       }
   }
   ```

5. Add daemon status indicator in header:
   - Show red/yellow/green indicator for daemon status
   - Show "Daemon not running" warning if disconnected

CRITICAL: Ensure proper Swift concurrency with async/await and MainActor.
  </action>
  <verify>
swift build 2>&1 | head -50
  </verify>
  <done>
Swift UI compiles, AppState has mount/unmount methods, MenuContentView shows mount controls and status.
  </done>
</task>

<task type="checkpoint:human-verify">
  <what-built>
Complete IPC integration between Swift UI and Rust daemon:
- Rust daemon has Unix socket IPC server accepting JSON commands
- Swift DaemonClient sends mount/unmount/getStatus commands
- Status bar menu shows bucket list with mount/unmount buttons
- Mount status updates every 2 seconds from daemon
- Visual indicators show mounted state (green icon)
  </what-built>
  <how-to-verify>
1. Build and run the daemon:
   ```bash
   cd Daemon/CloudMountDaemon && cargo run
   ```

2. In another terminal, verify daemon is listening:
   ```bash
   ls -la /tmp/cloudmount.sock
   ```

3. Build and run the Swift app:
   ```bash
   swift run
   ```

4. Test the full flow:
   - Click status bar icon
   - Verify daemon shows as "connected" (green indicator)
   - Add a bucket in settings (if not already configured)
   - Click "Mount" button
   - Verify bucket mounts and icon turns green
   - Open Finder and verify bucket appears in /Volumes/
   - Browse directories in the mounted bucket
   - Click "Unmount" button
   - Verify bucket disappears from /Volumes/

5. Check daemon logs for IPC command processing
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
Overall phase checks:
- [ ] Rust daemon has IPC server on Unix socket
- [ ] Swift DaemonClient connects and sends commands
- [ ] Mount/unmount commands work end-to-end
- [ ] Status bar shows mount status correctly
- [ ] One-click unmount works from menu
</verification>

<success_criteria>
1. IPC protocol defined with JSON serialization
2. Rust IpcServer handles Mount, Unmount, GetStatus commands
3. Swift DaemonClient sends commands over Unix socket
4. AppState tracks mount status with periodic updates
5. MenuContentView shows mount/unmount buttons per bucket
6. Visual indicators show daemon connection and mount state
7. End-to-end test: mount bucket -> browse in Finder -> unmount from menu
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-mount-browse/02-04-SUMMARY.md`
</output>
