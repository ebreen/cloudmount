---
phase: 02-core-mount-browse
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [
  "Daemon/CloudMountDaemon/src/b2/client.rs",
  "Daemon/CloudMountDaemon/src/mount/manager.rs",
  "Daemon/CloudMountDaemon/src/mount/mod.rs",
  "Daemon/CloudMountDaemon/src/fs/b2fs.rs"
]
autonomous: true

must_haves:
  truths:
    - "B2 API client can authenticate and make requests"
    - "Mount manager can mount a bucket to /Volumes/"
    - "Mount manager can unmount a bucket cleanly"
    - "FUSE filesystem connects to real B2 API for directory listing"
    - "Multiple buckets can be mounted simultaneously"
  artifacts:
    - path: "Daemon/CloudMountDaemon/src/b2/client.rs"
      provides: "B2Client for API authentication and requests"
      exports: ["B2Client", "authorize_account", "list_file_names"]
    - path: "Daemon/CloudMountDaemon/src/mount/manager.rs"
      provides: "MountManager for lifecycle management"
      exports: ["MountManager", "mount", "unmount", "list_mounts"]
    - path: "Daemon/CloudMountDaemon/src/fs/b2fs.rs"
      provides: "Updated B2Filesystem with real B2 client integration"
  key_links:
    - from: "mount/manager.rs"
      to: "fs/b2fs.rs"
      via: "B2Filesystem instantiation"
      pattern: "B2Filesystem::new"
    - from: "fs/b2fs.rs"
      to: "b2/client.rs"
      via: "B2Client for API calls"
      pattern: "b2_client.list_file_names"
    - from: "b2/client.rs"
      to: "B2 API"
      via: "HTTPS requests to api.backblazeb2.com"
      pattern: "reqwest Client"
---

<objective>
Build the B2 API client and mount manager to enable real bucket mounting with live directory browsing.

Purpose: This connects the stub filesystem from 02-01 to real Backblaze B2 data, enabling the core user experience of mounting and browsing buckets.

Output: Working mount/unmount lifecycle with B2 API integration for directory listings.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-mount-browse/02-RESEARCH.md

# Prior plan output (when available)
@.planning/phases/02-core-mount-browse/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement B2 API client with authentication</name>
  <files>
    Daemon/CloudMountDaemon/src/b2/client.rs
    Daemon/CloudMountDaemon/src/b2/mod.rs
  </files>
  <action>
Implement the B2 API client for cloud storage operations (from RESEARCH.md Pattern 5):

1. Create `src/b2/client.rs` with `B2Client` struct:
   ```rust
   pub struct B2Client {
       http_client: reqwest::Client,
       account_id: String,
       auth_token: String,
       api_url: String,
       bucket_id: String,
   }
   ```

2. Implement authentication:
   - `authorize_account(key_id: &str, key: &str) -> Result<Self>`
   - POST to https://api.backblazeb2.com/b2api/v2/b2_authorize_account
   - Use HTTP Basic Auth with base64(key_id:key)
   - Parse response for auth_token, api_url, account_id
   - Store http_client with 30-second timeout

3. Implement directory listing:
   - `list_file_names(&self, prefix: &str, delimiter: &str) -> Result<Vec<FileInfo>>`
   - GET to {api_url}/b2api/v2/b2_list_file_names
   - Query params: bucketId, prefix, delimiter ("/"), maxFileCount (1000)
   - Handle pagination with startFileName
   - Return Vec<FileInfo> from types.rs

4. Add error handling:
   - Custom B2Error enum for API errors
   - Handle 401 (unauthorized), 429 (rate limited), etc.
   - Use anyhow for error propagation

5. Update `src/b2/mod.rs` to export client module

CRITICAL: Auth tokens expire after 24 hours. For now, implement simple auth without refresh (will add in Phase 3). Document this limitation.
  </action>
  <verify>
cd Daemon/CloudMountDaemon && cargo check --lib
  </verify>
  <done>
B2Client compiles with authorize_account and list_file_names methods, error types defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build mount manager for lifecycle management</name>
  <files>
    Daemon/CloudMountDaemon/src/mount/manager.rs
    Daemon/CloudMountDaemon/src/mount/mod.rs
  </files>
  <action>
Implement the mount manager for controlling FUSE mounts (from RESEARCH.md Pattern 4):

1. Create `src/mount/manager.rs` with `MountManager` struct:
   ```rust
   pub struct MountManager {
       mounts: Arc<RwLock<HashMap<String, MountHandle>>>,
   }

   struct MountHandle {
       bucket_id: String,
       mountpoint: PathBuf,
       task: JoinHandle<()>,
   }
   ```

2. Implement mount operation:
   - `async fn mount(&self, bucket_id: String, mountpoint: PathBuf, b2_client: B2Client) -> Result<()>`
   - Create mountpoint directory if it doesn't exist: `fs::create_dir_all(&mountpoint)`
   - Build B2Filesystem with bucket_id and b2_client
   - Spawn blocking task for FUSE mount:
     ```rust
     let task = tokio::task::spawn_blocking(move || {
         let options = vec![
             MountOption::FSName(format!("cloudmount-{}", bucket_id)),
             MountOption::AllowOther,      // Required for /Volumes
             MountOption::NoAtime,         // Performance
             MountOption::AutoUnmount,     // Cleanup on exit
         ];
         mount2(fs, &mountpoint, &options)
     });
     ```
   - Store MountHandle in mounts HashMap

3. Implement unmount operation:
   - `async fn unmount(&self, bucket_id: &str) -> Result<()>`
   - Remove from HashMap, get MountHandle
   - Try graceful unmount first (signal channel if implemented)
   - Fallback to system umount: `Command::new("umount").arg(&mountpoint).output()`
   - Wait for task with timeout: `tokio::time::timeout(Duration::from_secs(5), handle.task).await`
   - Clean up mountpoint directory

4. Implement list_mounts:
   - `async fn list_mounts(&self) -> Vec<MountInfo>`
   - Return bucket_id and mountpoint for each active mount

5. Create `src/mount/mod.rs` exporting manager module

Use tokio::sync::RwLock for concurrent access to mounts map.
  </action>
  <verify>
cd Daemon/CloudMountDaemon && cargo check --lib
  </verify>
  <done>
MountManager compiles with mount, unmount, and list_mounts methods, uses proper async/sync boundaries.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate B2 client into FUSE filesystem</name>
  <files>
    Daemon/CloudMountDaemon/src/fs/b2fs.rs
  </files>
  <action>
Update B2Filesystem to use real B2 API calls (replacing stubs from 02-01):

1. Update struct to include B2Client:
   ```rust
   pub struct B2Filesystem {
       inode_table: Mutex<InodeTable>,
       b2_client: B2Client,
       bucket_id: String,
   }
   ```

2. Update `new()` constructor:
   - Accept B2Client and bucket_id
   - Initialize inode_table with root inode

3. Implement real `getattr`:
   - Get path from inode_table
   - For root (ino 1): Return directory attrs with current time
   - For other paths: Use B2 list_file_names with exact path
   - Convert FileInfo to FileAttr using b2_file_to_attr
   - Cache result (will use Moka in 02-03)

4. Implement real `lookup`:
   - Resolve parent ino to path prefix
   - Build full path: "{prefix}/{name}"
   - Query B2 for exact file match
   - Get/create inode for path
   - Return FileEntry with attrs

5. Implement real `readdir`:
   - Resolve ino to path prefix
   - Call b2_client.list_file_names(prefix, "/")
   - Add "." entry (current inode)
   - Add ".." entry (parent inode, or 1 if at root)
   - For each B2 file result:
     - Strip prefix from file_name to get entry name
     - Get/create inode for full path
     - Determine FileType from action field
     - Add to reply with reply.add()
   - Call reply.ok()

6. Handle edge cases:
   - Empty directories (B2 has no real directories, just prefixes)
   - Files with same prefix but different delimiters
   - Special characters in filenames

IMPORTANT: B2 doesn't have true directories - they're simulated via prefixes and delimiters. A "directory" is just a common prefix ending in "/".
  </action>
  <verify>
cd Daemon/CloudMountDaemon && cargo check --lib
  </verify>
  <done>
B2Filesystem uses real B2Client, getattr/lookup/readdir make actual API calls, handles directory simulation correctly.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create daemon main.rs with mount command support</name>
  <files>
    Daemon/CloudMountDaemon/src/main.rs
  </files>
  <action>
Update main.rs to support mounting buckets via CLI (for testing before IPC):

1. Add CLI argument parsing (use simple std::env or clap if preferred):
   ```rust
   enum Command {
       Mount { bucket_id: String, mountpoint: String, key_id: String, key: String },
       Unmount { bucket_id: String },
       List,
   }
   ```

2. Implement main with Tokio runtime:
   ```rust
   #[tokio::main]
   async fn main() -> anyhow::Result<()> {
       tracing_subscriber::fmt::init();
       
       let manager = MountManager::new();
       
       match parse_command() {
           Command::Mount { bucket_id, mountpoint, key_id, key } => {
               let b2_client = B2Client::authorize_account(&key_id, &key).await?;
               let path = PathBuf::from(mountpoint);
               manager.mount(bucket_id, path, b2_client).await?;
               
               // Keep running until signal
               tokio::signal::ctrl_c().await?;
               
               // Cleanup
               manager.unmount(&bucket_id).await?;
           }
           // ... other commands
       }
       
       Ok(())
   }
   ```

3. Add signal handling for graceful shutdown:
   - tokio::signal::ctrl_c() for SIGINT
   - Optional: SIGTERM handling

4. Add logging:
   - Use tracing::info! for mount/unmount events
   - Use tracing::debug! for FUSE operations
   - Use tracing::error! for failures

5. Ensure proper cleanup on exit:
   - AutoUnmount option handles most cases
   - Explicit unmount in ctrl_c handler as backup

This CLI interface is temporary for testing. IPC integration with Swift comes in 02-04.
  </action>
  <verify>
cd Daemon/CloudMountDaemon && cargo build
  </verify>
  <done>
Daemon compiles successfully, main.rs has CLI for mount/unmount/list, signal handling present.
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
- [ ] `cargo build` passes in Daemon/CloudMountDaemon/
- [ ] B2Client can authenticate with B2 API
- [ ] MountManager can create and track mounts
- [ ] B2Filesystem makes real API calls in getattr/lookup/readdir
- [ ] Daemon has CLI interface for testing
</verification>

<success_criteria>
1. B2Client implements b2_authorize_account and b2_list_file_names
2. MountManager handles mount/unmount lifecycle with proper cleanup
3. B2Filesystem integrates B2Client for live directory browsing
4. Daemon binary builds and can be tested via CLI
5. Multiple buckets can theoretically be mounted (manager supports it)
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-mount-browse/02-02-SUMMARY.md`
</output>
