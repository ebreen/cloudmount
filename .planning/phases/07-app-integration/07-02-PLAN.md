---
phase: 07-app-integration
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - CloudMount/AppState.swift
  - CloudMount/Views/MenuContentView.swift
  - CloudMount/Views/OnboardingView.swift
  - CloudMount/CloudMountApp.swift
autonomous: false

must_haves:
  truths:
    - "User can mount a B2 bucket from the menu bar by clicking Mount button"
    - "User can unmount a mounted B2 bucket from the menu bar by clicking Unmount button"
    - "Menu bar UI shows real-time mount status (mounted/unmounted/mounting/unmounting/error)"
    - "First launch detects extension status and guides user to System Settings if not enabled"
    - "All macFUSE and Phase 7 stub references are removed from the codebase"
  artifacts:
    - path: "CloudMount/AppState.swift"
      provides: "Mount status tracking via MountClient + MountMonitor integration"
      contains: "MountStatus"
    - path: "CloudMount/Views/MenuContentView.swift"
      provides: "Wired mount/unmount buttons with status indicators"
      contains: "mountStatus"
    - path: "CloudMount/Views/OnboardingView.swift"
      provides: "Extension setup guide with System Settings deep link"
      contains: "ExtensionDetector"
    - path: "CloudMount/CloudMountApp.swift"
      provides: "MountMonitor lifecycle and onboarding sheet"
      contains: "MountMonitor"
  key_links:
    - from: "CloudMount/AppState.swift"
      to: "CloudMount/MountClient.swift"
      via: "mountClient property, mount/unmount methods call mountClient"
      pattern: "mountClient\\.mount"
    - from: "CloudMount/AppState.swift"
      to: "CloudMount/MountMonitor.swift"
      via: "mountMonitor property, syncs status from NSWorkspace notifications"
      pattern: "mountMonitor"
    - from: "CloudMount/AppState.swift"
      to: "CloudMount/ExtensionDetector.swift"
      via: "extensionDetector property, checked on launch"
      pattern: "extensionDetector"
    - from: "CloudMount/Views/MenuContentView.swift"
      to: "CloudMount/AppState.swift"
      via: "reads mountStatus(for:), calls mount/unmount"
      pattern: "appState\\.mount|appState\\.unmount"
    - from: "CloudMount/Views/OnboardingView.swift"
      to: "CloudMount/ExtensionDetector.swift"
      via: "reads extensionDetector.status, calls openSystemSettings"
      pattern: "extensionDetector"
---

<objective>
Wire the three infrastructure components (MountClient, MountMonitor, ExtensionDetector) into AppState and the UI — replace mount/unmount stubs, add real-time status indicators, create onboarding view for extension setup, and remove all Phase 7 stub markers.

Purpose: This is the user-facing completion of Phase 7 — after this plan, users can mount/unmount B2 buckets from the menu bar with status feedback and guided extension setup.
Output: Updated AppState with mount orchestration, updated MenuContentView with live mount buttons, new OnboardingView, updated CloudMountApp with monitoring lifecycle.
</objective>

<execution_context>
@~/.config/Claude/get-shit-done/workflows/execute-plan.md
@~/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-app-integration/07-RESEARCH.md
@.planning/phases/07-app-integration/07-01-SUMMARY.md

# Files being modified
@CloudMount/AppState.swift
@CloudMount/Views/MenuContentView.swift
@CloudMount/CloudMountApp.swift

# Infrastructure files created in Plan 01
@CloudMount/MountClient.swift
@CloudMount/MountMonitor.swift
@CloudMount/ExtensionDetector.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewire AppState with mount orchestration and update MenuContentView</name>
  <files>CloudMount/AppState.swift, CloudMount/Views/MenuContentView.swift</files>
  <action>
**AppState.swift — Full rewrite of mount section:**

Add new published state:
- `@Published var mountStatuses: [UUID: MountStatus] = [:]` — keyed by MountConfiguration.id

Add nested `MountStatus` enum (inside AppState):
```
enum MountStatus: Equatable {
    case unmounted
    case mounting
    case mounted
    case unmounting
    case error(String)
}
```
Make it `Equatable` so SwiftUI can diff it. The `error(String)` case is already Equatable since String is Equatable.

Add properties:
- `let mountClient = MountClient()`
- `let mountMonitor = MountMonitor()`
- `let extensionDetector = ExtensionDetector()`
- `@Published var showOnboarding = false`

Replace the mount stub with:
```swift
func mount(_ config: MountConfiguration) {
    mountStatuses[config.id] = .mounting
    lastError = nil
    
    Task {
        do {
            try await mountClient.mount(config)
            // MountMonitor notification will update to .mounted,
            // but set it immediately as well for instant UI feedback
            mountStatuses[config.id] = .mounted
        } catch let error as MountClient.MountError {
            if case .extensionNotEnabled = error {
                showOnboarding = true
            }
            mountStatuses[config.id] = .error(error.localizedDescription)
            lastError = error.localizedDescription
        } catch {
            mountStatuses[config.id] = .error(error.localizedDescription)
            lastError = error.localizedDescription
        }
    }
}
```

Replace the unmount stub with:
```swift
func unmount(_ config: MountConfiguration) {
    mountStatuses[config.id] = .unmounting
    lastError = nil
    
    Task {
        do {
            try await mountClient.unmount(config)
            mountStatuses[config.id] = .unmounted
        } catch {
            mountStatuses[config.id] = .error(error.localizedDescription)
            lastError = error.localizedDescription
        }
    }
}
```

Add helper method:
```swift
func mountStatus(for config: MountConfiguration) -> MountStatus {
    mountStatuses[config.id] ?? .unmounted
}
```

Add startup method called from init (after loadState):
```swift
func startMonitoring() {
    mountMonitor.startMonitoring(configs: mountConfigs)
    
    // Sync initial mount status from MountMonitor
    for config in mountConfigs {
        if mountMonitor.isMounted(config) {
            mountStatuses[config.id] = .mounted
        }
    }
    
    // Check extension status on first launch
    Task {
        await extensionDetector.checkExtensionStatus()
        if extensionDetector.needsSetup {
            showOnboarding = true
        }
    }
}
```

Update init to call `startMonitoring()` after `loadState()`.

Update `clearAll()` to also call `mountMonitor.stopMonitoring()` and clear `mountStatuses`.

Remove the `// MARK: - Mount/Unmount Stubs (Phase 7)` section header and its comments entirely. The new methods are production code, not stubs.

**MenuContentView.swift — Wire mount buttons with status:**

In the `mountsSection`, replace the ForEach loop body for each config:

1. Change the drive icon to reflect mount status:
   - `.mounted` → `"externaldrive.fill.badge.checkmark"` with `.green` foreground
   - `.mounting` / `.unmounting` → show `ProgressView().controlSize(.mini)` instead of icon
   - `.error` → `"externaldrive.fill.badge.xmark"` with `.red` foreground
   - `.unmounted` → `"externaldrive.fill"` with `.blue` foreground (current)

2. Replace the static "Mount" button with a dynamic button:
   - Get status: `let status = appState.mountStatus(for: config)`
   - If `.unmounted` or `.error`: Show "Mount" button that calls `appState.mount(config)`, enabled
   - If `.mounted`: Show "Unmount" button that calls `appState.unmount(config)`, enabled
   - If `.mounting`: Show "Mounting…" button, disabled, with `.bordered` style
   - If `.unmounting`: Show "Unmounting…" button, disabled, with `.bordered` style

3. Remove `.disabled(true)` — buttons are now live.

4. Remove the comment `// Mount/unmount — stubs for Phase 7` and `// Enabled in Phase 7`.

5. Update the error display: instead of showing `appState.lastError` globally, show per-mount errors inline. For each config where `mountStatus == .error(let message)`, show the error message below that mount entry in a small red caption text.

Keep the global `lastError` display at the bottom as a fallback for non-mount errors.
  </action>
  <verify>Build succeeds: `xcodebuild -scheme CloudMount build CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO 2>&1 | tail -5` shows BUILD SUCCEEDED. Grep for "Phase 7" in AppState.swift and MenuContentView.swift returns no results. Grep for "MountStatus" in AppState.swift returns matches.</verify>
  <done>AppState mount/unmount methods use MountClient, MountMonitor tracks real-time status, ExtensionDetector probed on startup. MenuContentView mount buttons are live with status-dependent labels, icons, and enabled states. No "Phase 7" stub references remain.</done>
</task>

<task type="auto">
  <name>Task 2: Create OnboardingView and update CloudMountApp lifecycle</name>
  <files>CloudMount/Views/OnboardingView.swift, CloudMount/CloudMountApp.swift</files>
  <action>
**OnboardingView.swift — New file:**

Create a SwiftUI view for first-launch extension setup guidance.

```swift
import SwiftUI

struct OnboardingView: View {
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        VStack(spacing: 20) {
            // Icon
            Image(systemName: "externaldrive.fill.badge.icloud")
                .font(.system(size: 48))
                .foregroundStyle(.blue)
                .padding(.top, 20)
            
            // Title
            Text("Enable CloudMount Extension")
                .font(.title2)
                .fontWeight(.bold)
            
            // Description
            Text("CloudMount needs its file system extension enabled in System Settings to mount B2 buckets as local drives.")
                .font(.body)
                .foregroundStyle(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, 20)
            
            // Steps
            VStack(alignment: .leading, spacing: 12) {
                stepRow(number: 1, text: "Click \"Open System Settings\" below")
                stepRow(number: 2, text: "Find \"CloudMount\" in the extensions list")
                stepRow(number: 3, text: "Toggle it on")
                stepRow(number: 4, text: "Return here and try mounting")
            }
            .padding(.horizontal, 30)
            
            // Status indicator
            statusIndicator
            
            Spacer()
            
            // Buttons
            HStack(spacing: 12) {
                Button("Skip for Now") {
                    dismiss()
                }
                .buttonStyle(.bordered)
                
                Button("Open System Settings") {
                    appState.extensionDetector.openSystemSettings()
                }
                .buttonStyle(.borderedProminent)
            }
            .padding(.bottom, 20)
        }
        .frame(width: 400, height: 380)
    }
    
    private func stepRow(number: Int, text: String) -> some View {
        HStack(alignment: .top, spacing: 10) {
            Text("\(number)")
                .font(.caption)
                .fontWeight(.bold)
                .foregroundStyle(.white)
                .frame(width: 20, height: 20)
                .background(Circle().fill(.blue))
            Text(text)
                .font(.subheadline)
        }
    }
    
    @ViewBuilder
    private var statusIndicator: some View {
        switch appState.extensionDetector.status {
        case .enabled:
            HStack(spacing: 6) {
                Image(systemName: "checkmark.circle.fill")
                    .foregroundStyle(.green)
                Text("Extension is enabled!")
            }
            .font(.subheadline)
            .padding(10)
            .background(.green.opacity(0.1))
            .clipShape(RoundedRectangle(cornerRadius: 8))
        case .disabled:
            HStack(spacing: 6) {
                Image(systemName: "xmark.circle.fill")
                    .foregroundStyle(.orange)
                Text("Extension not yet enabled")
            }
            .font(.subheadline)
            .padding(10)
            .background(.orange.opacity(0.1))
            .clipShape(RoundedRectangle(cornerRadius: 8))
        case .checking:
            HStack(spacing: 6) {
                ProgressView().controlSize(.small)
                Text("Checking extension status...")
            }
            .font(.subheadline)
        case .unknown:
            EmptyView()
        }
    }
}
```

**CloudMountApp.swift — Add monitoring lifecycle and onboarding sheet:**

1. Add `.onAppear` modifier to the `MenuContentView()` inside MenuBarExtra that calls `appState.startMonitoring()` — but only once. Use a `@State private var hasStartedMonitoring = false` flag to guard it.

Actually, better approach: call `appState.startMonitoring()` in a `.task {}` modifier on MenuContentView — `.task` is called once per view lifetime and supports async.

Wait — `startMonitoring()` is not async. Use `.onAppear` with the guard flag.

2. Add a `.sheet` modifier on the MenuBarExtra content (MenuContentView) that presents OnboardingView when `appState.showOnboarding` is true:
```swift
MenuContentView()
    .environmentObject(appState)
    .onAppear {
        if !hasStartedMonitoring {
            appState.startMonitoring()
            hasStartedMonitoring = true
        }
    }
    .sheet(isPresented: $appState.showOnboarding) {
        OnboardingView()
            .environmentObject(appState)
    }
```

Note: The `$appState.showOnboarding` binding requires access to the StateObject. Since `appState` is `@StateObject`, `$appState.showOnboarding` should work because `showOnboarding` is `@Published`.

Actually, `.sheet` on a MenuBarExtra window may not work as expected. Instead, present onboarding as a separate Window scene:

```swift
Window("CloudMount Setup", id: "onboarding") {
    OnboardingView()
        .environmentObject(appState)
}
.windowResizability(.contentSize)
.defaultPosition(.center)
```

And in `startMonitoring()`, when `showOnboarding = true` is set, use `openWindow(id: "onboarding")` instead. But `openWindow` requires `@Environment(\.openWindow)` which isn't available from AppState.

**Simplest approach:** Use `.sheet` on the MenuContentView itself. MenuBarExtra with `.window` style does support sheets. The sheet will appear as a modal over the menu bar popover.

If that doesn't work at runtime, it can be adjusted — but structurally this is the cleanest approach. Add:
```swift
.sheet(isPresented: $appState.showOnboarding) {
    OnboardingView()
        .environmentObject(appState)
}
```
to the MenuContentView body (wrap existing content in a container if needed, or apply to the outermost VStack).

3. Move the `.sheet` INTO `MenuContentView.swift` rather than `CloudMountApp.swift` — this keeps the presentation logic close to the UI. Add it as a modifier on the outermost VStack in MenuContentView's body.

4. Add the `.onAppear { appState.startMonitoring() }` call with the guard flag inside `CloudMountApp.swift` on the MenuBarExtra content block, OR inside MenuContentView's `.onAppear`. Prefer inside CloudMountApp on the MenuContentView for clarity — but use `.task {}` instead since it's lifecycle-bound:

In CloudMountApp.swift, update the MenuBarExtra content:
```swift
MenuBarExtra {
    MenuContentView()
        .environmentObject(appState)
        .task {
            appState.startMonitoring()
        }
} label: { ... }
```

Wait — `startMonitoring()` is synchronous (not async), so `.task` would work but is overkill. However, `startMonitoring()` does launch a `Task` internally for `extensionDetector.checkExtensionStatus()`. So `.onAppear` is fine. But `.onAppear` on MenuBarExtra content may fire each time the popover opens. Use a guard:

In CloudMountApp.swift, add `@State private var hasStartedMonitoring = false` and:
```swift
MenuBarExtra {
    MenuContentView()
        .environmentObject(appState)
        .onAppear {
            guard !hasStartedMonitoring else { return }
            hasStartedMonitoring = true
            appState.startMonitoring()
        }
} label: { ... }
```

**Summary of changes to CloudMountApp.swift:**
- Add `@State private var hasStartedMonitoring = false`
- Add `.onAppear` with guard + `appState.startMonitoring()` on MenuContentView
- No new Window scene needed — onboarding uses .sheet in MenuContentView

**Summary of changes to MenuContentView.swift (additional to Task 1):**
- Add `.sheet(isPresented: $appState.showOnboarding)` presenting OnboardingView at the end of the body VStack
  </action>
  <verify>Build succeeds: `xcodebuild -scheme CloudMount build CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO 2>&1 | tail -5` shows BUILD SUCCEEDED. `CloudMount/Views/OnboardingView.swift` exists. Grep for "startMonitoring" in CloudMountApp.swift returns a match. Grep for "OnboardingView" in MenuContentView.swift returns a match.</verify>
  <done>OnboardingView created with step-by-step extension setup guide and System Settings deep link. CloudMountApp starts mount monitoring on first appear. Onboarding sheet presented when extension is not enabled. Full project builds successfully.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete mount/unmount integration: MountClient, MountMonitor, ExtensionDetector wired into AppState and UI. Menu bar shows live mount buttons with status. Onboarding guides extension setup.
  </what-built>
  <how-to-verify>
    1. Build and run CloudMount app (`xcodebuild -scheme CloudMount build && open build/Debug/CloudMount.app`)
    2. Click the menu bar icon — verify mounts section shows configured buckets (if any) with Mount buttons that are ENABLED (not disabled/greyed out)
    3. If extension is not enabled in System Settings: verify onboarding sheet appears with "Enable CloudMount Extension" guidance
    4. Click "Open System Settings" in onboarding — verify it opens System Settings to Extensions pane
    5. Enable the CloudMount extension in System Settings
    6. Click "Mount" on a configured bucket — verify button changes to "Mounting…" then to "Unmount" (or shows error if B2 credentials invalid)
    7. If mounted: verify the volume appears at /Volumes/bucketName and in Finder sidebar
    8. Click "Unmount" — verify button changes back to "Mount" and volume disappears
    9. Verify no "Phase 7", "stub", or "macFUSE" text appears anywhere in the UI
  </how-to-verify>
  <resume-signal>Type "approved" if mount/unmount works end-to-end, or describe any issues encountered</resume-signal>
</task>

</tasks>

<verification>
1. `CloudMount/AppState.swift` — MountStatus enum exists, mount/unmount methods use MountClient, MountMonitor/ExtensionDetector instantiated
2. `CloudMount/Views/MenuContentView.swift` — Mount/Unmount buttons are live (not disabled), status-dependent icons and labels
3. `CloudMount/Views/OnboardingView.swift` — Extension setup guide with System Settings deep link
4. `CloudMount/CloudMountApp.swift` — startMonitoring() called on first appear
5. No "Phase 7 stub" or "macFUSE" references in any CloudMount/*.swift files
6. Full project builds: `xcodebuild -scheme CloudMount build CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO` succeeds
7. Human verification: mount/unmount works end-to-end with real B2 bucket
</verification>

<success_criteria>
- User can click Mount in menu bar → bucket mounts at /Volumes/bucketName → appears in Finder
- User can click Unmount → bucket unmounts → disappears from Finder
- Mount status updates in real-time (mounted/unmounted/mounting/unmounting/error)
- Extension not enabled → onboarding sheet guides user to System Settings
- No stub or macFUSE references remain in codebase
- Full project builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-app-integration/07-02-SUMMARY.md`
</output>
