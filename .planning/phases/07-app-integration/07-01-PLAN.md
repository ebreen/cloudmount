---
phase: 07-app-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - CloudMount/MountClient.swift
  - CloudMount/MountMonitor.swift
  - CloudMount/ExtensionDetector.swift
autonomous: true

must_haves:
  truths:
    - "MountClient can invoke mount -F to mount a B2 bucket and umount/diskutil to unmount"
    - "MountMonitor observes NSWorkspace mount/unmount notifications and tracks which paths are mounted"
    - "ExtensionDetector can probe whether the FSKit extension is enabled and open System Settings if not"
  artifacts:
    - path: "CloudMount/MountClient.swift"
      provides: "Process-based mount/unmount operations for B2 buckets via FSKit"
      contains: "mount -F"
    - path: "CloudMount/MountMonitor.swift"
      provides: "Real-time mount status monitoring via NSWorkspace notifications"
      contains: "didMountNotification"
    - path: "CloudMount/ExtensionDetector.swift"
      provides: "FSKit extension enablement detection and System Settings deep link"
      contains: "ExtensionDetector"
  key_links:
    - from: "CloudMount/MountClient.swift"
      to: "CloudMountKit/Credentials/MountConfig.swift"
      via: "import CloudMountKit, accepts MountConfiguration"
      pattern: "MountConfiguration"
    - from: "CloudMount/MountMonitor.swift"
      to: "CloudMountKit/Credentials/MountConfig.swift"
      via: "accepts [MountConfiguration] for status checking"
      pattern: "MountConfiguration"
---

<objective>
Create the three infrastructure components for FSKit mount orchestration: MountClient (Process-based mount/unmount), MountMonitor (NSWorkspace notification observer), and ExtensionDetector (heuristic extension probe).

Purpose: These are the foundational building blocks that AppState and the UI will consume in Plan 02 to provide mount/unmount functionality and real-time status feedback.
Output: Three new Swift files in the CloudMount host app target, each self-contained and independently testable.
</objective>

<execution_context>
@~/.config/Claude/get-shit-done/workflows/execute-plan.md
@~/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-app-integration/07-RESEARCH.md

# Source files that define types used by these new files
@CloudMountKit/Credentials/MountConfig.swift
@CloudMountExtension/Info.plist
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MountClient — Process-based mount/unmount</name>
  <files>CloudMount/MountClient.swift</files>
  <action>
Create `CloudMount/MountClient.swift` with a `@MainActor final class MountClient` that wraps Foundation `Process` for mount and unmount operations.

**MountError enum:**
- `mountFailed(String)` — mount command returned non-zero, includes stderr
- `unmountFailed(String)` — unmount command returned non-zero, includes stderr
- `mountPointCreationFailed` — could not create /Volumes/bucketName directory
- `extensionNotEnabled` — stderr contains "not found" indicating extension not enabled
- Conform to `LocalizedError` with `errorDescription` for each case

**mount(_ config: MountConfiguration) async throws:**
1. Create mount point directory if it doesn't exist: `FileManager.default.createDirectory(atPath: config.mountPoint, withIntermediateDirectories: true)`
2. Build the resource URL: `b2://\(config.bucketName)?accountId=\(config.accountId.uuidString)` — use URLComponents to properly encode the URL (set scheme to "b2", host to config.bucketName, queryItems to [URLQueryItem(name: "accountId", value: config.accountId.uuidString)])
3. Run `/sbin/mount` with arguments `["-F", "-t", "b2", resourceURL, config.mountPoint]`
4. If exit code != 0: check stderr for "not found" or "extensionKit" → throw `.extensionNotEnabled`; otherwise throw `.mountFailed(stderr)`
5. On success, return normally (MountMonitor will detect the mount via notification)

**unmount(_ config: MountConfiguration) async throws:**
1. First try `/usr/sbin/diskutil` with arguments `["unmount", config.mountPoint]` (more graceful, handles busy volumes better)
2. If diskutil fails (exit code != 0), fallback to `/sbin/umount` with arguments `[config.mountPoint]`
3. If both fail, throw `.unmountFailed(stderr)` with the second error's stderr
4. On success, clean up mount point directory if it's empty: `try? FileManager.default.removeItem(atPath: config.mountPoint)` (best-effort, don't throw if fails)

**private runProcess(_ path: String, arguments: [String]) async throws -> (exitCode: Int32, stderr: String):**
Use `withCheckedThrowingContinuation` + `Process.terminationHandler` to avoid blocking the main thread (do NOT use `waitUntilExit()`). Capture stderr via Pipe. Discard stdout via separate Pipe.

**Important:** Import `CloudMountKit` for `MountConfiguration`. Import `os` for `Logger`. Add a logger: `Logger(subsystem: "com.cloudmount.app", category: "MountClient")`. Log mount/unmount attempts and outcomes at `.info` level, errors at `.error` level.
  </action>
  <verify>Build succeeds: `xcodebuild -scheme CloudMount build CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO 2>&1 | tail -5` shows BUILD SUCCEEDED</verify>
  <done>MountClient.swift exists with mount/unmount methods that use Process to invoke /sbin/mount -F and umount/diskutil, with proper async/await via terminationHandler continuation, error classification, mount point directory management, and structured logging</done>
</task>

<task type="auto">
  <name>Task 2: Create MountMonitor and ExtensionDetector</name>
  <files>CloudMount/MountMonitor.swift, CloudMount/ExtensionDetector.swift</files>
  <action>
**MountMonitor.swift:**

Create `@MainActor final class MountMonitor: ObservableObject` that uses NSWorkspace notifications for real-time mount status tracking.

Published state:
- `@Published var mountedPaths: Set<String> = []` — currently mounted paths from our configs

Methods:
- `startMonitoring(configs: [MountConfiguration])` — (1) Call `refreshMountStatus(configs:)` for initial state, (2) Register observer for `NSWorkspace.didMountNotification` on `.main` queue — extract URL from `NSWorkspace.volumeURLUserInfoKey`, insert path into `mountedPaths`, (3) Register observer for `NSWorkspace.didUnmountNotification` on `.main` queue — extract URL, remove path from `mountedPaths`. Store observers in `private var observers: [NSObjectProtocol] = []`.
- `stopMonitoring()` — Remove all observers from `NSWorkspace.shared.notificationCenter`, clear array.
- `isMounted(_ config: MountConfiguration) -> Bool` — return `mountedPaths.contains(config.mountPoint)`
- `refreshMountStatus(configs: [MountConfiguration])` — For each config, check if mount point exists AND is actually a mount point (not just an empty directory). Use `stat()` to compare device IDs: call `stat(config.mountPoint, &mountStat)` and `stat((config.mountPoint as NSString).deletingLastPathComponent, &parentStat)` — if device IDs differ, it's a real mount point. Add to `mountedPaths` if mounted, remove if not.

Import `CloudMountKit` for `MountConfiguration`. Import `os` for `Logger`.

**ExtensionDetector.swift:**

Create `@MainActor final class ExtensionDetector: ObservableObject` that checks FSKit extension enablement.

Published state:
- `@Published var status: ExtensionStatus = .unknown`

Nested enum `ExtensionStatus`:
- `.unknown` — haven't checked yet
- `.checking` — probe in progress
- `.enabled` — extension found
- `.disabled` — extension not found

Methods:
- `checkExtensionStatus() async` — Set status to `.checking`. Run Process `/sbin/mount` with arguments `["-d", "-F", "-t", "b2", "b2://probe", "/tmp/cloudmount-probe"]` (dry-run probe). Use same async runProcess pattern as MountClient (terminationHandler + continuation). If stderr contains "not found" or "extensionKit" → `.disabled`. Otherwise → `.enabled`. On Process.run() throwing → `.unknown`.
- `openSystemSettings()` — Open URL `"x-apple.systempreferences:com.apple.LoginItems-Settings.extension"` via `NSWorkspace.shared.open(url)`. This deep-links to the Login Items & Extensions pane.
- `var needsSetup: Bool` — computed: returns `status == .disabled || status == .unknown`

Import `os` for `Logger`.
  </action>
  <verify>Build succeeds: `xcodebuild -scheme CloudMount build CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO 2>&1 | tail -5` shows BUILD SUCCEEDED</verify>
  <done>MountMonitor.swift observes NSWorkspace mount notifications and tracks mounted paths with device-ID-based mount detection. ExtensionDetector.swift probes extension enablement via dry-run mount and can open System Settings. Both files build successfully as part of CloudMount target.</done>
</task>

</tasks>

<verification>
1. All three new files exist: `CloudMount/MountClient.swift`, `CloudMount/MountMonitor.swift`, `CloudMount/ExtensionDetector.swift`
2. Full project builds: `xcodebuild -scheme CloudMount build CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO` succeeds
3. MountClient uses `withCheckedThrowingContinuation` (not `waitUntilExit`) for non-blocking Process execution
4. MountMonitor uses `NSWorkspace.didMountNotification` / `didUnmountNotification` (not polling)
5. ExtensionDetector uses heuristic probe approach (not reading enabledModules.plist)
6. All three import CloudMountKit or use its types where needed
</verification>

<success_criteria>
- Three new infrastructure files created and building as part of CloudMount target
- MountClient invokes `/sbin/mount -F -t b2` for mount, `diskutil unmount` (with umount fallback) for unmount
- MountMonitor provides push-based mount status via NSWorkspace notifications
- ExtensionDetector can check extension status and open System Settings
- No UI changes in this plan — that's Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/07-app-integration/07-01-SUMMARY.md`
</output>
