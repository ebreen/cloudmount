---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src-tauri/src/credentials.rs
  - src-tauri/src/commands.rs
  - src-tauri/src/lib.rs
  - src-tauri/Cargo.toml
  - src-tauri/capabilities/default.json
autonomous: true
user_setup:
  - service: macOS Keychain
    why: "Secure credential storage for Backblaze B2 credentials"
    note: "Uses macOS native Keychain — no additional setup required"
must_haves:
  truths:
    - "Credentials are stored securely in macOS Keychain"
    - "Credentials persist between app restarts"
    - "Multiple sets of credentials can be stored (for different buckets)"
    - "Credentials are never stored in plain text or local files"
  artifacts:
    - path: "src-tauri/src/credentials.rs"
      provides: "Secure credential storage using macOS Keychain"
      exports: ["CredentialStore", "save_credentials", "get_credentials", "delete_credentials"]
    - path: "src-tauri/src/commands.rs"
      provides: "Tauri commands for credential operations"
      exports: ["save_bucket_credentials", "get_bucket_credentials", "delete_bucket_credentials"]
  key_links:
    - from: "src-tauri/src/commands.rs"
      to: "src-tauri/src/credentials.rs"
      via: "Call credential store functions from command handlers"
    - from: "src-tauri/src/credentials.rs"
      to: "macOS Keychain"
      via: "security-framework or keyring crate"
---

<objective>
Create secure credential storage using macOS Keychain

Purpose: Store Backblaze B2 credentials (application key ID and key) securely using macOS native Keychain, ensuring credentials persist between app restarts and are never exposed in plain text.

Output: Rust module for credential storage with save, retrieve, and delete operations backed by macOS Keychain.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/research/STACK.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

## Phase Context
This plan implements secure credential storage for CONFIG-03 and CONFIG-04. Credentials must be stored in macOS Keychain, not in local files or plain text.

## Key Decisions from Context
- Credential fields: Application Key ID and Application Key
- Multiple credentials: Support multiple B2 accounts
- Credential editing: Can edit existing credentials
- Security visibility: Masked by default (password dots with reveal toggle) — UI concern, not this plan

## Keychain Storage Strategy
Use the `keyring` crate or `security-framework` crate to interact with macOS Keychain.
- Service name: "cloudmount"
- Account name: bucket identifier or "default"
- Password: JSON string with { key_id, application_key }

## Security Requirements
- Never log credentials
- Never store in localStorage, files, or user defaults
- Use Keychain's secure enclave when available
- Handle Keychain access errors gracefully
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add keychain dependency and create credentials module</name>
  <files>src-tauri/Cargo.toml, src-tauri/src/credentials.rs, src-tauri/src/lib.rs</files>
  <action>
    Set up the credentials storage infrastructure:
    
    1. Update src-tauri/Cargo.toml:
       - Add keyring = "3" (cross-platform keychain access)
       - Or security-framework = "3" (macOS native)
       - Recommendation: use `keyring` crate for simpler API
       
    2. Create src-tauri/src/credentials.rs:
       - Define BucketCredentials struct:
         ```rust
         pub struct BucketCredentials {
             pub bucket_name: String,
             pub key_id: String,
             pub application_key: String,
         }
         ```
       - Define CredentialStore struct (wrapper for keyring operations)
       - Implement error type: CredentialError with variants for KeychainError, NotFound, etc.
       
    3. Implement core functions:
       - save_credentials(creds: &BucketCredentials) -> Result<(), CredentialError>
         * Use keyring::Entry::new("cloudmount", &creds.bucket_name)
         * Store JSON: serde_json::to_string(creds)
       - get_credentials(bucket_name: &str) -> Result<BucketCredentials, CredentialError>
         * Retrieve password, parse JSON
       - delete_credentials(bucket_name: &str) -> Result<(), CredentialError>
       - list_credentials() -> Result<Vec<String>, CredentialError> (list bucket names)
       
    4. Update src-tauri/src/lib.rs:
       - Add pub mod credentials;
       - Re-export necessary types
       
    5. Add unit tests:
       - Test save and retrieve roundtrip
       - Test delete
       - Test not found error
       
    IMPORTANT: Handle keyring errors gracefully — Keychain may be locked or unavailable.
  </action>
  <verify>
    Run `cargo check` — compiles without errors
    Run `cargo test` — credential tests pass
  </verify>
  <done>
    credentials.rs module exists with BucketCredentials struct and save/get/delete functions. Uses keyring crate. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Tauri commands for credential operations</name>
  <files>src-tauri/src/commands.rs, src-tauri/capabilities/default.json</files>
  <action>
    Expose credential operations to the frontend via Tauri commands:
    
    1. Update src-tauri/src/commands.rs:
       - Define request/response structs:
         ```rust
         #[derive(Deserialize)]
         struct SaveCredentialsRequest {
             bucket_name: String,
             key_id: String,
             application_key: String,
         }
         
         #[derive(Serialize)]
         struct CredentialsResponse {
             success: bool,
             error: Option<String>,
         }
         ```
       
       - Implement #[tauri::command] async fn save_bucket_credentials(request: SaveCredentialsRequest) -> CredentialsResponse
         * Call credentials::save_credentials()
         * Return success or error message
         
       - Implement #[tauri::command] async fn get_bucket_credentials(bucket_name: String) -> Result<BucketCredentials, String>
         * Return credentials or error string
         
       - Implement #[tauri::command] async fn delete_bucket_credentials(bucket_name: String) -> CredentialsResponse
         
       - Implement #[tauri::command] async fn list_stored_buckets() -> Result<Vec<String>, String>
         * Return list of bucket names with stored credentials
       
    2. Update src-tauri/src/lib.rs:
       - Register new commands in invoke_handler:
         ```rust
         .invoke_handler(tauri::generate_handler![
             commands::check_macfuse,
             commands::save_bucket_credentials,
             commands::get_bucket_credentials,
             commands::delete_bucket_credentials,
             commands::list_stored_buckets,
         ])
         ```
       
    3. Update capabilities (src-tauri/capabilities/default.json for Tauri v2):
       - Add permissions for the new commands
       
    4. Security considerations:
       - Never log the application_key
       - Log only bucket_name and key_id (first 4 chars only) for debugging
       - Return generic error messages to frontend (don't expose keychain internals)
  </action>
  <verify>
    Run `cargo tauri dev`
    Test via browser console:
    - invoke('save_bucket_credentials', { bucket_name: 'test', key_id: 'abc', application_key: 'xyz' })
    - invoke('get_bucket_credentials', { bucketName: 'test' })
    - invoke('list_stored_buckets')
    - invoke('delete_bucket_credentials', { bucketName: 'test' })
    All commands should work and persist across app restarts.
  </verify>
  <done>
    All credential commands work from frontend. Credentials persist in Keychain across app restarts. No credentials logged or exposed.
  </done>
</task>

<task type="auto">
  <name>Task 3: Test credential persistence and security</name>
  <files>src-tauri/src/credentials.rs</files>
  <action>
    Verify credential storage meets security requirements:
    
    1. Add integration tests to src-tauri/src/credentials.rs:
       - Test that credentials persist across CredentialStore instances
       - Test that different bucket names don't collide
       - Test error handling for invalid bucket names
       - Test that Keychain errors are properly wrapped
       
    2. Manual verification:
       - Run app with `cargo tauri dev`
       - Save credentials for a test bucket
       - Quit app completely
       - Re-launch app
       - Retrieve credentials — should return same values
       - Check Keychain Access app — should see "cloudmount" entries
       
    3. Security verification:
       - Verify credentials not in:
         * LocalStorage
         * Any files in project directory
         * Console logs
         * Terminal output
       - Verify credentials ARE in:
         * macOS Keychain (visible in Keychain Access app)
         
    4. Edge cases:
       - Empty strings (should error or handle gracefully)
       - Very long keys (should handle without truncation)
       - Special characters in bucket names (should work)
       - Unicode (should work)
  </action>
  <verify>
    Run `cargo test` — all tests pass
    Manual test: Credentials persist across app restart
    Keychain Access app shows "cloudmount" entries
    No credential data in app logs or files
  </verify>
  <done>
    Credentials persist across restarts. Stored in macOS Keychain only. No plain text storage. Edge cases handled.
  </done>
</task>

</tasks>

<verification>
1. Credentials can be saved via Tauri command
2. Credentials can be retrieved after app restart
3. Credentials are stored in macOS Keychain (visible in Keychain Access)
4. Multiple bucket credentials can be stored independently
5. Credentials can be deleted
6. No credential data appears in logs or files
</verification>

<success_criteria>
- Credentials stored securely in macOS Keychain
- Credentials persist between app restarts
- Multiple credentials supported
- No plain text storage anywhere
- Proper error handling for Keychain failures
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
