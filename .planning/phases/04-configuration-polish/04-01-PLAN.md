---
phase: 04-configuration-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Sources/CloudMount/CloudMountApp.swift
  - Daemon/CloudMountDaemon/src/ipc/protocol.rs
  - Daemon/CloudMountDaemon/src/ipc/server.rs
  - Daemon/CloudMountDaemon/src/mount/manager.rs
autonomous: true

must_haves:
  truths:
    - "Bucket configs persist across app restarts"
    - "Daemon reports total_bytes_used per mounted bucket in status"
    - "Adding or removing buckets in settings survives app quit and relaunch"
  artifacts:
    - path: "Sources/CloudMount/CloudMountApp.swift"
      provides: "BucketConfig Codable conformance, BucketConfigStore, AppState persistence wiring"
      contains: "BucketConfigStore"
    - path: "Daemon/CloudMountDaemon/src/ipc/protocol.rs"
      provides: "total_bytes_used field on MountInfo"
      contains: "total_bytes_used"
    - path: "Daemon/CloudMountDaemon/src/ipc/server.rs"
      provides: "Usage calculation when building GetStatus response"
      contains: "total_bytes_used"
  key_links:
    - from: "Sources/CloudMount/CloudMountApp.swift"
      to: "~/Library/Application Support/CloudMount/buckets.json"
      via: "BucketConfigStore.save/load"
      pattern: "BucketConfigStore\\.(save|load)"
    - from: "Daemon/CloudMountDaemon/src/ipc/server.rs"
      to: "Daemon/CloudMountDaemon/src/ipc/protocol.rs"
      via: "MountInfo construction with total_bytes_used"
      pattern: "total_bytes_used"
---

<objective>
Add bucket config persistence and disk usage IPC protocol extension.

Purpose: Bucket configs currently live only in memory — they're lost on app restart. The IPC protocol also lacks disk usage data needed for the menu display. This plan adds both foundational pieces.
Output: BucketConfigStore persisting to JSON, and total_bytes_used field flowing through IPC.
</objective>

<execution_context>
@~/.config/Claude/get-shit-done/workflows/execute-plan.md
@~/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-configuration-polish/04-RESEARCH.md
@Sources/CloudMount/CloudMountApp.swift
@Sources/CloudMount/DaemonClient.swift
@Daemon/CloudMountDaemon/src/ipc/protocol.rs
@Daemon/CloudMountDaemon/src/ipc/server.rs
@Daemon/CloudMountDaemon/src/mount/manager.rs
@Daemon/CloudMountDaemon/src/b2/client.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bucket config persistence with BucketConfigStore</name>
  <files>Sources/CloudMount/CloudMountApp.swift</files>
  <action>
Make BucketConfig persistable and wire auto-save/load into AppState. All changes in CloudMountApp.swift:

1. **Make BucketConfig Codable** — Add `Codable` conformance. Add a `CodingKeys` enum that includes `id`, `name`, `mountpoint` but EXCLUDES `isMounted` (runtime state, must not be persisted — would cause stale "mounted" state on restart). Also add `totalBytesUsed: Int64?` property (not persisted, populated from daemon status). Add it to Hashable if needed (exclude from hash).

2. **Create BucketConfigStore** — Add a struct with static methods:
   - `fileURL` computed property: `~/Library/Application Support/CloudMount/buckets.json`. Use `FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!`, append "CloudMount" directory, call `createDirectory(withIntermediateDirectories: true)` before returning the URL. Append "buckets.json".
   - `save(_ configs: [BucketConfig])`: Encode with JSONEncoder (prettyPrinted), write to fileURL. Use `try?` — silent failure is fine for config save.
   - `load() -> [BucketConfig]`: Read Data from fileURL, decode with JSONDecoder. Return empty array on failure.

3. **Wire into AppState** — In `init()`, load persisted configs: `bucketConfigs = BucketConfigStore.load()` (before `checkMacFUSE()` and `startStatusPolling()`). In `addBucket()`, after appending to `bucketConfigs`, call `BucketConfigStore.save(bucketConfigs)`. In `removeBucket()`, after removing, call `BucketConfigStore.save(bucketConfigs)`.

4. **Update mount status sync** — In `updateDaemonStatus()`, when updating bucket configs with mount status, also populate `totalBytesUsed` from `DaemonMountInfo.totalBytesUsed` (will be nil until Plan 02 wires the display, but the data path should be ready).

**IMPORTANT:** Do NOT persist `isMounted` or `totalBytesUsed`. Both are runtime state from daemon polling. The `CodingKeys` enum must exclude them.

**IMPORTANT:** The `disconnect()` method in CredentialsPane (SettingsView.swift) calls `appState.bucketConfigs = []`. After this plan, that direct assignment won't trigger save. Add a `clearBuckets()` method to AppState that clears and saves, OR add `BucketConfigStore.save([])` call in the disconnect flow. Simplest: just add save call in `removeBucket` and also handle the `bucketConfigs = []` case by adding a `clearAllBuckets()` method to AppState.
  </action>
  <verify>
Build the Swift app: `swift build` from project root. No compilation errors. Inspect that BucketConfig has Codable, BucketConfigStore exists with save/load, and AppState.init loads from store.
  </verify>
  <done>
BucketConfig is Codable with CodingKeys excluding isMounted. BucketConfigStore.save/load works with ~/Library/Application Support/CloudMount/buckets.json. AppState loads on init, saves on add/remove. totalBytesUsed property exists on BucketConfig (unpersisted).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add disk usage to IPC protocol and daemon status</name>
  <files>
    Daemon/CloudMountDaemon/src/ipc/protocol.rs
    Daemon/CloudMountDaemon/src/ipc/server.rs
    Daemon/CloudMountDaemon/src/mount/manager.rs
    Sources/CloudMount/DaemonClient.swift
  </files>
  <action>
Extend IPC protocol with disk usage data. The daemon will calculate bucket usage from its B2 client and include it in status responses.

**Rust side:**

1. **protocol.rs** — Add `total_bytes_used: Option<u64>` to `MountInfo` struct. Use `#[serde(default)]` on it for backward compatibility. Update the test `test_serialize_status_response` to include the new field.

2. **manager.rs** — The MountManager needs to track B2Client per mount so the server can query usage. Currently MountHandle stores a `task: JoinHandle<()>` but not the B2Client. The B2Client is moved into B2Filesystem on mount. 

   **Simplest approach for MVP:** Instead of complex refactoring, have the daemon do a lightweight calculation. Add a `usage_bytes` field to `MountHandle`: `usage_bytes: Arc<RwLock<Option<u64>>>`. When building the mount, clone this Arc into B2Filesystem (requires B2Filesystem change — but that's complex). 
   
   **Even simpler MVP approach:** Just add `total_bytes_used: Option<u64>` to the `MountInfo` struct in manager.rs (the local one, not protocol.rs). In `list_mounts()`, return it as `None` for now. The actual calculation can be wired later or in a follow-up. The key thing is the protocol supports it.

   Actually, the **simplest correct approach**: Keep `MountInfo` in manager.rs simple. In server.rs's `process_command` for `GetStatus`, just set `total_bytes_used: None` on each MountInfo. The field exists in the protocol, Swift can read it, and the UI will show "Calculating..." or nothing when nil. This is the MVP path — the field is there, the pipe works end-to-end, and the daemon can be enhanced later to actually calculate usage.

3. **server.rs** — In `process_command` for `Command::GetStatus`, when building `MountInfo` instances, add `total_bytes_used: None`. This ensures the field is serialized as null in JSON.

**Swift side:**

4. **DaemonClient.swift** — Add `totalBytesUsed: Int64?` to `DaemonMountInfo` struct. Since it's optional with default nil, old daemon responses without the field will still deserialize correctly (JSON decoder treats missing optional fields as nil).

**Why None for now:** B2 has NO "get bucket size" API. Computing it requires listing all files and summing content_length — potentially thousands of API calls for large buckets. The research recommends a background task with 5-minute refresh. For this plan, getting the protocol pipe working end-to-end is the goal. The actual computation can be added as an enhancement.
  </action>
  <verify>
Build Rust daemon: `cargo build` from `Daemon/CloudMountDaemon/`. Run tests: `cargo test` from same directory. Build Swift app: `swift build` from project root. Both compile without errors. Rust tests pass (including updated status serialization test).
  </verify>
  <done>
MountInfo in protocol.rs has total_bytes_used: Option<u64>. Server sends it as None in GetStatus responses. DaemonMountInfo in Swift has totalBytesUsed: Int64?. Protocol pipe works end-to-end. Tests pass.
  </done>
</task>

</tasks>

<verification>
1. `swift build` succeeds from project root
2. `cargo build` succeeds from Daemon/CloudMountDaemon/
3. `cargo test` passes from Daemon/CloudMountDaemon/
4. BucketConfigStore.save/load pattern is in CloudMountApp.swift
5. total_bytes_used field exists in both Rust MountInfo and Swift DaemonMountInfo
</verification>

<success_criteria>
- BucketConfig has Codable conformance with CodingKeys excluding isMounted
- BucketConfigStore persists to ~/Library/Application Support/CloudMount/buckets.json
- AppState loads configs on init, saves on add/remove
- IPC protocol MountInfo has total_bytes_used: Option<u64>
- DaemonMountInfo has totalBytesUsed: Int64?
- Both Swift and Rust projects build cleanly
- Rust tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-configuration-polish/04-01-SUMMARY.md`
</output>
